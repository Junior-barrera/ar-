<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Pok√©mon Style - Detecci√≥n 3D</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #000;
            user-select: none;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
        }
        
        #threejs-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 15px 20px;
            border-radius: 20px;
            font-size: 14px;
            max-width: 300px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            pointer-events: none;
            animation: crosshairPulse 2s infinite;
        }
        
        #crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 10px;
            height: 10px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
        }
        
        @keyframes crosshairPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
        }
        
        #controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            pointer-events: auto;
        }
        
        .control-btn {
            background: rgba(255, 255, 255, 0.95);
            border: none;
            padding: 15px 25px;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            font-size: 14px;
            border: 2px solid transparent;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 1);
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        .control-btn.active {
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            color: white;
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        #catchBtn {
            background: linear-gradient(45deg, #FF6B6B, #FF8E53);
            color: white;
            font-size: 16px;
            padding: 18px 35px;
            animation: catchPulse 2s infinite;
        }
        
        @keyframes catchPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        #permissionDialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .dialog-content {
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 25px;
            text-align: center;
            max-width: 400px;
            margin: 20px;
            backdrop-filter: blur(20px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
        }
        
        .dialog-btn {
            background: linear-gradient(45deg, #4ECDC4, #44A08D);
            color: white;
            border: none;
            padding: 18px 35px;
            border-radius: 30px;
            cursor: pointer;
            font-size: 16px;
            margin: 15px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .dialog-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }
        
        .surface-grid {
            position: absolute;
            pointer-events: none;
            z-index: 300;
            opacity: 0.6;
        }
        
        .surface-point {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #4ECDC4;
            border-radius: 50%;
            animation: surfaceGlow 1.5s infinite;
            box-shadow: 0 0 10px #4ECDC4;
        }
        
        @keyframes surfaceGlow {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.5); opacity: 1; }
        }
        
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 998;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            max-width: 350px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .pokemon-indicator {
            position: absolute;
            font-size: 24px;
            z-index: 500;
            animation: bounce 2s infinite;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-15px); }
        }
        
        .catch-effect {
            position: absolute;
            width: 100px;
            height: 100px;
            border: 3px solid #FFD700;
            border-radius: 50%;
            animation: catchEffect 1s ease-out;
            pointer-events: none;
            z-index: 800;
        }
        
        @keyframes catchEffect {
            0% { 
                transform: scale(0) rotate(0deg); 
                opacity: 1; 
                border-color: #FFD700;
            }
            100% { 
                transform: scale(3) rotate(360deg); 
                opacity: 0; 
                border-color: #FF6B6B;
            }
        }
    </style>
</head>
<body>
    <div id="permissionDialog">
        <div class="dialog-content">
            <h2>üéÆ AR Pok√©mon Experience</h2>
            <p>¬°Experimenta realidad aumentada con objetos 3D!</p>
            <p>üîπ Detecci√≥n autom√°tica de superficies</p>
            <p>üîπ Objetos 3D realistas</p>
            <p>üîπ Efectos visuales avanzados</p>
            <button class="dialog-btn" onclick="requestCamera()">üöÄ Iniciar Aventura AR</button>
        </div>
    </div>

    <div id="container" style="display: none;">
        <video id="video" autoplay muted playsinline></video>
        <div id="threejs-container"></div>
        
        <div id="ui">
            <h3>üéØ AR Pok√©mon Hunter</h3>
            <p><strong>Estado:</strong> <span id="status">Iniciando...</span></p>
            <p><strong>Superficies:</strong> <span id="surfaceCount">0</span></p>
            <p><strong>Pok√©mon:</strong> <span id="pokemonCount">0</span></p>
            <div style="margin-top: 10px; font-size: 12px; opacity: 0.8;">
                üü¢ Mueve la c√°mara lentamente<br>
                üéØ Apunta al centro para capturar
            </div>
        </div>
        
        <div id="crosshair"></div>
        
        <div id="instructions">
            <h3>üì± Busca Pok√©mon Salvajes</h3>
            <p>Apunta la c√°mara hacia:</p>
            <ul style="text-align: left;">
                <li>üè† Superficies planas (mesas, suelo)</li>
                <li>üìö Libros o revistas</li>
                <li>üåø C√©sped o √°reas abiertas</li>
                <li>üéØ Cualquier superficie estable</li>
            </ul>
            <p><small>Los puntos azules indican d√≥nde pueden aparecer Pok√©mon</small></p>
        </div>
        
        <div id="controls">
            <button class="control-btn active" onclick="selectPokemon('pikachu')">‚ö° Pikachu</button>
            <button class="control-btn" onclick="selectPokemon('pokeball')">‚ö™ Pok√©ball</button>
            <button class="control-btn" onclick="selectPokemon('charmander')">üî• Charmander</button>
            <button class="control-btn" onclick="selectPokemon('squirtle')">üíß Squirtle</button>
            <button id="catchBtn" class="control-btn" onclick="catchPokemon()">üéØ ¬°Capturar!</button>
            <button class="control-btn" onclick="clearAll()">üóëÔ∏è Limpiar</button>
        </div>
    </div>

    <script>
        // Variables globales
        let video, scene, camera, renderer;
        let currentPokemon = 'pikachu';
        let surfacePoints = [];
        let placedObjects = [];
        let isInitialized = false;
        let pokemonCount = 0;
        let animationId;
        
        // Configuraci√≥n Three.js
        function initThreeJS() {
            const container = document.getElementById('threejs-container');
            
            // Crear escena
            scene = new THREE.Scene();
            
            // Configurar c√°mara
            camera = new THREE.PerspectiveCamera(
                75, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                1000
            );
            camera.position.z = 5;
            
            // Crear renderer
            renderer = new THREE.WebGLRenderer({ 
                alpha: true, 
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            container.appendChild(renderer.domElement);
            
            // A√±adir luces
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Iniciar loop de renderizado
            animate();
        }
        
        // Crear geometr√≠as 3D para diferentes Pok√©mon
        function createPokemon3D(type, position) {
            let mesh;
            
            switch(type) {
                case 'pikachu':
                    // Cuerpo de Pikachu
                    const pikachuGroup = new THREE.Group();
                    
                    // Cuerpo principal
                    const bodyGeometry = new THREE.SphereGeometry(0.8, 16, 16);
                    const bodyMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xFFD700,
                        shininess: 30
                    });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.castShadow = true;
                    pikachuGroup.add(body);
                    
                    // Orejas
                    const earGeometry = new THREE.ConeGeometry(0.2, 0.6, 8);
                    const earMaterial = new THREE.MeshPhongMaterial({ color: 0xFFD700 });
                    
                    const leftEar = new THREE.Mesh(earGeometry, earMaterial);
                    leftEar.position.set(-0.4, 0.8, 0);
                    leftEar.rotation.z = -0.3;
                    pikachuGroup.add(leftEar);
                    
                    const rightEar = new THREE.Mesh(earGeometry, earMaterial);
                    rightEar.position.set(0.4, 0.8, 0);
                    rightEar.rotation.z = 0.3;
                    pikachuGroup.add(rightEar);
                    
                    // Puntas negras de las orejas
                    const tipGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                    const tipMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
                    
                    const leftTip = new THREE.Mesh(tipGeometry, tipMaterial);
                    leftTip.position.set(-0.5, 1.2, 0);
                    pikachuGroup.add(leftTip);
                    
                    const rightTip = new THREE.Mesh(tipGeometry, tipMaterial);
                    rightTip.position.set(0.5, 1.2, 0);
                    pikachuGroup.add(rightTip);
                    
                    // Mejillas rojas
                    const cheekGeometry = new THREE.CircleGeometry(0.15, 8);
                    const cheekMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xFF6B6B,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const leftCheek = new THREE.Mesh(cheekGeometry, cheekMaterial);
                    leftCheek.position.set(-0.6, 0.2, 0.7);
                    pikachuGroup.add(leftCheek);
                    
                    const rightCheek = new THREE.Mesh(cheekGeometry, cheekMaterial);
                    rightCheek.position.set(0.6, 0.2, 0.7);
                    pikachuGroup.add(rightCheek);
                    
                    mesh = pikachuGroup;
                    break;
                    
                case 'pokeball':
                    const pokeballGroup = new THREE.Group();
                    
                    // Mitad superior (roja)
                    const topGeometry = new THREE.SphereGeometry(0.6, 16, 8, 0, Math.PI * 2, 0, Math.PI * 0.5);
                    const topMaterial = new THREE.MeshPhongMaterial({ color: 0xFF4444 });
                    const topHalf = new THREE.Mesh(topGeometry, topMaterial);
                    topHalf.castShadow = true;
                    pokeballGroup.add(topHalf);
                    
                    // Mitad inferior (blanca)
                    const bottomGeometry = new THREE.SphereGeometry(0.6, 16, 8, 0, Math.PI * 2, Math.PI * 0.5, Math.PI * 0.5);
                    const bottomMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
                    const bottomHalf = new THREE.Mesh(bottomGeometry, bottomMaterial);
                    bottomHalf.castShadow = true;
                    pokeballGroup.add(bottomHalf);
                    
                    // Banda central
                    const bandGeometry = new THREE.CylinderGeometry(0.62, 0.62, 0.1, 16);
                    const bandMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
                    const band = new THREE.Mesh(bandGeometry, bandMaterial);
                    band.rotation.x = Math.PI / 2;
                    pokeballGroup.add(band);
                    
                    // Bot√≥n central
                    const buttonGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                    const buttonMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
                    const button = new THREE.Mesh(buttonGeometry, buttonMaterial);
                    button.position.z = 0.62;
                    pokeballGroup.add(button);
                    
                    mesh = pokeballGroup;
                    break;
                    
                case 'charmander':
                    const charmanderGroup = new THREE.Group();
                    
                    // Cuerpo
                    const charBodyGeometry = new THREE.SphereGeometry(0.7, 16, 16);
                    const charBodyMaterial = new THREE.MeshPhongMaterial({ color: 0xFF8C42 });
                    const charBody = new THREE.Mesh(charBodyGeometry, charBodyMaterial);
                    charBody.castShadow = true;
                    charmanderGroup.add(charBody);
                    
                    // Cola con fuego
                    const tailGeometry = new THREE.ConeGeometry(0.15, 1.2, 8);
                    const tailMaterial = new THREE.MeshPhongMaterial({ color: 0xFF8C42 });
                    const tail = new THREE.Mesh(tailGeometry, tailMaterial);
                    tail.position.set(0.8, 0.2, -0.5);
                    tail.rotation.z = -0.8;
                    charmanderGroup.add(tail);
                    
                    // Llama de la cola
                    const flameGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                    const flameMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xFF4444,
                        emissive: 0xFF2222,
                        emissiveIntensity: 0.3
                    });
                    const flame = new THREE.Mesh(flameGeometry, flameMaterial);
                    flame.position.set(1.3, 0.8, -0.5);
                    charmanderGroup.add(flame);
                    
                    mesh = charmanderGroup;
                    break;
                    
                case 'squirtle':
                    const squirtleGroup = new THREE.Group();
                    
                    // Caparaz√≥n
                    const shellGeometry = new THREE.SphereGeometry(0.8, 16, 16);
                    const shellMaterial = new THREE.MeshPhongMaterial({ color: 0x4A90E2 });
                    const shell = new THREE.Mesh(shellGeometry, shellMaterial);
                    shell.castShadow = true;
                    squirtleGroup.add(shell);
                    
                    // Cabeza
                    const headGeometry = new THREE.SphereGeometry(0.4, 12, 12);
                    const headMaterial = new THREE.MeshPhongMaterial({ color: 0x87CEEB });
                    const head = new THREE.Mesh(headGeometry, headMaterial);
                    head.position.set(0, 0.2, 0.9);
                    squirtleGroup.add(head);
                    
                    // Patas
                    const legGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                    const legMaterial = new THREE.MeshPhongMaterial({ color: 0x87CEEB });
                    
                    const positions = [
                        [-0.6, -0.8, 0.3], [0.6, -0.8, 0.3],
                        [-0.4, -0.8, -0.6], [0.4, -0.8, -0.6]
                    ];
                    
                    positions.forEach(pos => {
                        const leg = new THREE.Mesh(legGeometry, legMaterial);
                        leg.position.set(...pos);
                        squirtleGroup.add(leg);
                    });
                    
                    mesh = squirtleGroup;
                    break;
                    
                default:
                    // Pok√©mon por defecto
                    const defaultGeometry = new THREE.SphereGeometry(0.8, 16, 16);
                    const defaultMaterial = new THREE.MeshPhongMaterial({ color: 0xFFD700 });
                    mesh = new THREE.Mesh(defaultGeometry, defaultMaterial);
                    mesh.castShadow = true;
            }
            
            // Posicionar el objeto
            if (position) {
                mesh.position.copy(position);
            }
            
            // A√±adir animaci√≥n de flotaci√≥n
            mesh.userData = {
                originalY: mesh.position.y,
                time: 0,
                floatSpeed: 0.02 + Math.random() * 0.01,
                floatAmount: 0.1 + Math.random() * 0.05
            };
            
            return mesh;
        }
        
        // Solicitar permiso de c√°mara
        async function requestCamera() {
            try {
                document.getElementById('permissionDialog').style.display = 'none';
                document.getElementById('container').style.display = 'block';
                await init();
            } catch (error) {
                console.error('Error al solicitar c√°mara:', error);
                alert('Error al acceder a la c√°mara. Por favor, recarga la p√°gina y permite el acceso.');
            }
        }
        
        // Inicializar la aplicaci√≥n
        async function init() {
            if (isInitialized) return;
            
            try {
                updateStatus('Iniciando c√°mara...');
                
                // Configurar video
                video = document.getElementById('video');
                
                // Inicializar Three.js
                initThreeJS();
                
                // Solicitar acceso a la c√°mara
                const constraints = {
                    video: { 
                        facingMode: { ideal: 'environment' },
                        width: { ideal: 1280, max: 1920 },
                        height: { ideal: 720, max: 1080 }
                    },
                    audio: false
                };
                
                updateStatus('Solicitando acceso a c√°mara...');
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                
                video.srcObject = stream;
                
                video.onloadedmetadata = () => {
                    video.play().then(() => {
                        updateStatus('‚úÖ C√°mara iniciada - Detectando superficies');
                        document.getElementById('instructions').style.display = 'block';
                        
                        // Iniciar detecci√≥n de superficies
                        startAdvancedSurfaceDetection();
                        
                        isInitialized = true;
                    }).catch(error => {
                        console.error('Error al reproducir video:', error);
                        updateStatus('‚ùå Error al iniciar video');
                    });
                };
                
            } catch (error) {
                console.error('Error en init:', error);
                updateStatus('‚ùå Error al acceder a la c√°mara');
                
                if (error.name === 'NotAllowedError') {
                    alert('Acceso a la c√°mara denegado. Por favor, permite el acceso y recarga la p√°gina.');
                } else if (error.name === 'NotFoundError') {
                    alert('No se encontr√≥ ninguna c√°mara. Aseg√∫rate de que tu dispositivo tenga una c√°mara.');
                } else {
                    alert('Error al acceder a la c√°mara: ' + error.message);
                }
            }
        }
        
        // Detecci√≥n avanzada de superficies
        function startAdvancedSurfaceDetection() {
            setInterval(() => {
                if (video && video.readyState === video.HAVE_ENOUGH_DATA) {
                    detectAdvancedSurfaces();
                }
            }, 500);
        }
        
        // Detectar superficies con algoritmo mejorado
        function detectAdvancedSurfaces() {
            if (!video || !video.videoWidth || !video.videoHeight) return;
            
            // Limpiar puntos anteriores
            clearSurfaceIndicators();
            surfacePoints = [];
            
            try {
                // Crear canvas temporal para an√°lisis
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = Math.min(video.videoWidth, 200);
                tempCanvas.height = Math.min(video.videoHeight, 150);
                
                // Dibujar video en canvas temporal
                tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);
                
                // Obtener datos de imagen
                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const data = imageData.data;
                
                // An√°lisis mejorado de superficies
                const gridSize = 20;
                const threshold = 30;
                
                for (let y = gridSize; y < tempCanvas.height - gridSize; y += gridSize) {
                    for (let x = gridSize; x < tempCanvas.width - gridSize; x += gridSize) {
                        // Calcular m√∫ltiples m√©tricas
                        const gradient = calculateGradient(data, x, y, gridSize, tempCanvas.width);
                        const contrast = calculateContrast(data, x, y, gridSize, tempCanvas.width);
                        const uniformity = calculateUniformity(data, x, y, gridSize, tempCanvas.width);
                        
                        // Algoritmo de puntuaci√≥n compuesto
                        const surfaceScore = (
                            (1 - gradient / 100) * 0.4 +
                            (1 - contrast / 100) * 0.3 +
                            uniformity * 0.3
                        );
                        
                        // Si la puntuaci√≥n es alta, es probablemente una superficie
                        if (surfaceScore > 0.6 && Math.random() > 0.3) {
                            const screenX = (x / tempCanvas.width) * window.innerWidth;
                            const screenY = (y / tempCanvas.height) * window.innerHeight;
                            
                            surfacePoints.push({ 
                                x: screenX, 
                                y: screenY, 
                                confidence: surfaceScore,
                                time: Date.now(),
                                gradient: gradient,
                                contrast: contrast,
                                uniformity: uniformity
                            });
                            
                            showAdvancedSurfaceIndicator(screenX, screenY, surfaceScore);
                        }
                    }
                }
                
                // A√±adir puntos simulados si no hay suficientes
                if (surfacePoints.length < 3) {
                    addEnhancedSimulatedSurfaces();
                }
                
                // Spawning autom√°tico de Pok√©mon
                if (surfacePoints.length > 0 && Math.random() > 0.95) {
                    autoSpawnPokemon();
                }
                
                updateSurfaceCount(surfacePoints.length);
                
                if (surfacePoints.length > 0) {
                    updateStatus(`üü¢ ${surfacePoints.length} superficie(s) detectada(s)`);
                    document.getElementById('instructions').style.display = 'none';
                } else {
                    updateStatus('üîç Buscando superficies...');
                    if (placedObjects.length === 0) {
                        document.getElementById('instructions').style.display = 'block';
                    }
                }
                
            } catch (error) {
                console.error('Error en detecci√≥n:', error);
                addEnhancedSimulatedSurfaces();
            }
        }
        
        // Calcular contraste (continuaci√≥n)
        function calculateContrast(data, centerX, centerY, size, width) {
            const halfSize = Math.floor(size / 2);
            let min = 255, max = 0;
            
            for (let dy = -halfSize; dy < halfSize; dy++) {
                for (let dx = -halfSize; dx < halfSize; dx++) {
                    const x = centerX + dx;
                    const y = centerY + dy;
                    if (x >= 0 && x < width && y >= 0) {
                        const idx = (y * width + x) * 4;
                        const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                        min = Math.min(min, brightness);
                        max = Math.max(max, brightness);
                    }
                }
            }
            return max - min;
        }
        
        // Calcular gradiente
        function calculateGradient(data, centerX, centerY, size, width) {
            const halfSize = Math.floor(size / 2);
            let gradientSum = 0;
            let count = 0;
            
            for (let dy = -halfSize; dy < halfSize - 1; dy++) {
                for (let dx = -halfSize; dx < halfSize - 1; dx++) {
                    const x = centerX + dx;
                    const y = centerY + dy;
                    if (x >= 0 && x < width - 1 && y >= 0) {
                        const idx1 = (y * width + x) * 4;
                        const idx2 = (y * width + (x + 1)) * 4;
                        const idx3 = ((y + 1) * width + x) * 4;
                        
                        const b1 = (data[idx1] + data[idx1 + 1] + data[idx1 + 2]) / 3;
                        const b2 = (data[idx2] + data[idx2 + 1] + data[idx2 + 2]) / 3;
                        const b3 = (data[idx3] + data[idx3 + 1] + data[idx3 + 2]) / 3;
                        
                        const gradX = Math.abs(b2 - b1);
                        const gradY = Math.abs(b3 - b1);
                        gradientSum += Math.sqrt(gradX * gradX + gradY * gradY);
                        count++;
                    }
                }
            }
            return count > 0 ? gradientSum / count : 0;
        }
        
        // Calcular uniformidad
        function calculateUniformity(data, centerX, centerY, size, width) {
            const halfSize = Math.floor(size / 2);
            let values = [];
            
            for (let dy = -halfSize; dy < halfSize; dy++) {
                for (let dx = -halfSize; dx < halfSize; dx++) {
                    const x = centerX + dx;
                    const y = centerY + dy;
                    if (x >= 0 && x < width && y >= 0) {
                        const idx = (y * width + x) * 4;
                        const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                        values.push(brightness);
                    }
                }
            }
            
            if (values.length === 0) return 0;
            
            const mean = values.reduce((a, b) => a + b) / values.length;
            const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
            const stdDev = Math.sqrt(variance);
            
            return Math.max(0, 1 - stdDev / 50); // Normalizar
        }
        
        // Mostrar indicador avanzado de superficie
        function showAdvancedSurfaceIndicator(x, y, confidence) {
            const indicator = document.createElement('div');
            indicator.className = 'surface-point';
            indicator.style.left = (x - 4) + 'px';
            indicator.style.top = (y - 4) + 'px';
            indicator.style.background = `hsl(${180 + confidence * 60}, 70%, 60%)`;
            indicator.style.boxShadow = `0 0 ${10 + confidence * 10}px hsl(${180 + confidence * 60}, 70%, 60%)`;
            
            document.body.appendChild(indicator);
            
            // Remover despu√©s de 2 segundos
            setTimeout(() => {
                if (indicator.parentNode) {
                    indicator.parentNode.removeChild(indicator);
                }
            }, 2000);
        }
        
        // Limpiar indicadores de superficie
        function clearSurfaceIndicators() {
            const indicators = document.querySelectorAll('.surface-point');
            indicators.forEach(indicator => {
                if (indicator.parentNode) {
                    indicator.parentNode.removeChild(indicator);
                }
            });
        }
        
        // A√±adir superficies simuladas mejoradas
        function addEnhancedSimulatedSurfaces() {
            const patterns = [
                // Patr√≥n en cuadr√≠cula
                { x: 0.3, y: 0.4 }, { x: 0.7, y: 0.4 },
                { x: 0.3, y: 0.6 }, { x: 0.7, y: 0.6 },
                // Patr√≥n en L
                { x: 0.2, y: 0.3 }, { x: 0.2, y: 0.7 }, { x: 0.5, y: 0.7 },
                // Patr√≥n diagonal
                { x: 0.4, y: 0.2 }, { x: 0.6, y: 0.4 }, { x: 0.8, y: 0.6 }
            ];
            
            patterns.forEach((pattern, index) => {
                const x = pattern.x * window.innerWidth;
                const y = pattern.y * window.innerHeight;
                const confidence = 0.7 + Math.random() * 0.3;
                
                surfacePoints.push({
                    x: x,
                    y: y,
                    confidence: confidence,
                    time: Date.now(),
                    simulated: true,
                    pattern: index
                });
                
                showAdvancedSurfaceIndicator(x, y, confidence);
            });
        }
        
        // Spawn autom√°tico de Pok√©mon
        function autoSpawnPokemon() {
            if (surfacePoints.length === 0) return;
            
            const randomSurface = surfacePoints[Math.floor(Math.random() * surfacePoints.length)];
            const pokemonTypes = ['pikachu', 'pokeball', 'charmander', 'squirtle'];
            const randomType = pokemonTypes[Math.floor(Math.random() * pokemonTypes.length)];
            
            placePokemonAt(randomSurface.x, randomSurface.y, randomType);
            
            // Mostrar indicador de aparici√≥n
            showPokemonSpawnEffect(randomSurface.x, randomSurface.y, randomType);
        }
        
        // Mostrar efecto de aparici√≥n de Pok√©mon
        function showPokemonSpawnEffect(x, y, type) {
            const effect = document.createElement('div');
            effect.className = 'pokemon-indicator';
            effect.innerHTML = getPokemonEmoji(type);
            effect.style.left = (x - 12) + 'px';
            effect.style.top = (y - 12) + 'px';
            
            document.body.appendChild(effect);
            
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
            }, 3000);
        }
        
        // Obtener emoji de Pok√©mon
        function getPokemonEmoji(type) {
            const emojis = {
                'pikachu': '‚ö°',
                'pokeball': '‚ö™',
                'charmander': 'üî•',
                'squirtle': 'üíß'
            };
            return emojis[type] || '‚ö°';
        }
        
        // Colocar Pok√©mon en posici√≥n espec√≠fica
        function placePokemonAt(screenX, screenY, type) {
            // Convertir coordenadas de pantalla a coordenadas 3D
            const x = (screenX / window.innerWidth) * 10 - 5;
            const y = -(screenY / window.innerHeight) * 6 + 3;
            const z = -2 - Math.random() * 3;
            
            const position = new THREE.Vector3(x, y, z);
            const pokemon = createPokemon3D(type || currentPokemon, position);
            
            scene.add(pokemon);
            placedObjects.push(pokemon);
            
            pokemonCount++;
            updatePokemonCount(pokemonCount);
            
            // Efecto de aparici√≥n
            pokemon.scale.set(0, 0, 0);
            const targetScale = 1;
            
            function scaleUp() {
                if (pokemon.scale.x < targetScale) {
                    pokemon.scale.x += 0.05;
                    pokemon.scale.y += 0.05;
                    pokemon.scale.z += 0.05;
                    requestAnimationFrame(scaleUp);
                }
            }
            scaleUp();
        }
        
        // Seleccionar tipo de Pok√©mon
        function selectPokemon(type) {
            currentPokemon = type;
            
            // Actualizar botones
            document.querySelectorAll('.control-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            event.target.classList.add('active');
            updateStatus(`üéØ Seleccionado: ${type.charAt(0).toUpperCase() + type.slice(1)}`);
        }
        
        // Capturar Pok√©mon
        function catchPokemon() {
            if (surfacePoints.length === 0) {
                updateStatus('‚ùå No hay superficies detectadas');
                return;
            }
            
            // Encontrar superficie m√°s cercana al centro
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            let closestSurface = null;
            let minDistance = Infinity;
            
            surfacePoints.forEach(surface => {
                const distance = Math.sqrt(
                    Math.pow(surface.x - centerX, 2) + 
                    Math.pow(surface.y - centerY, 2)
                );
                if (distance < minDistance) {
                    minDistance = distance;
                    closestSurface = surface;
                }
            });
            
            if (closestSurface && minDistance < 100) {
                placePokemonAt(closestSurface.x, closestSurface.y, currentPokemon);
                showCatchEffect(closestSurface.x, closestSurface.y);
                updateStatus(`‚úÖ ¬°${currentPokemon.charAt(0).toUpperCase() + currentPokemon.slice(1)} capturado!`);
            } else {
                // Colocar en el centro si no hay superficie cercana
                placePokemonAt(centerX, centerY, currentPokemon);
                showCatchEffect(centerX, centerY);
                updateStatus(`‚úÖ ¬°${currentPokemon.charAt(0).toUpperCase() + currentPokemon.slice(1)} apareci√≥!`);
            }
        }
        
        // Mostrar efecto de captura
        function showCatchEffect(x, y) {
            const effect = document.createElement('div');
            effect.className = 'catch-effect';
            effect.style.left = (x - 50) + 'px';
            effect.style.top = (y - 50) + 'px';
            
            document.body.appendChild(effect);
            
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
            }, 1000);
        }
        
        // Limpiar todos los objetos
        function clearAll() {
            // Remover objetos de la escena
            placedObjects.forEach(obj => {
                scene.remove(obj);
            });
            
            placedObjects = [];
            pokemonCount = 0;
            
            updatePokemonCount(0);
            updateStatus('üóëÔ∏è Escena limpiada');
        }
        
        // Actualizar estado
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }
        
        // Actualizar contador de superficies
        function updateSurfaceCount(count) {
            document.getElementById('surfaceCount').textContent = count;
        }
        
        // Actualizar contador de Pok√©mon
        function updatePokemonCount(count) {
            document.getElementById('pokemonCount').textContent = count;
        }
        
        // Loop de animaci√≥n
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            // Animar objetos colocados
            placedObjects.forEach(obj => {
                if (obj.userData) {
                    obj.userData.time += obj.userData.floatSpeed;
                    obj.position.y = obj.userData.originalY + 
                        Math.sin(obj.userData.time) * obj.userData.floatAmount;
                    
                    // Rotaci√≥n suave
                    obj.rotation.y += 0.01;
                }
            });
            
            // Renderizar escena
            renderer.render(scene, camera);
        }
        
        // Manejar redimensionamiento
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Manejar orientaci√≥n en m√≥viles
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }, 100);
        });
        
        // Controles t√°ctiles
        let touchStartX = 0;
        let touchStartY = 0;
        
        document.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });
        
        document.addEventListener('touchend', (e) => {
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            
            const deltaX = Math.abs(touchEndX - touchStartX);
            const deltaY = Math.abs(touchEndY - touchStartY);
            
            // Si fue un tap r√°pido (no deslizamiento)
            if (deltaX < 10 && deltaY < 10) {
                // Colocar Pok√©mon donde se hizo tap
                placePokemonAt(touchEndX, touchEndY, currentPokemon);
                showCatchEffect(touchEndX, touchEndY);
            }
        });
        
        // Efectos de sonido simulados
        function playSound(type) {
            // Vibraci√≥n en dispositivos m√≥viles
            if (navigator.vibrate) {
                switch(type) {
                    case 'catch':
                        navigator.vibrate([100, 50, 100]);
                        break;
                    case 'spawn':
                        navigator.vibrate(200);
                        break;
                }
            }
        }
        
        // Auto-inicializaci√≥n mejorada
        document.addEventListener('DOMContentLoaded', () => {
            // A√±adir eventos a botones
            document.querySelectorAll('.control-btn').forEach(btn => {
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    btn.style.transform = 'scale(0.95)';
                });
                
                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    btn.style.transform = 'scale(1)';
                });
            });
            
            // Precargar recursos
            updateStatus('üéÆ Listo para iniciar AR');
        });
        
        // Funciones de utilidad adicionales
        function getRandomPosition() {
            return {
                x: Math.random() * window.innerWidth,
                y: Math.random() * window.innerHeight
            };
        }
        
        function createParticleEffect(x, y, color = 0xFFD700) {
            const particles = new THREE.Group();
            
            for (let i = 0; i < 20; i++) {
                const geometry = new THREE.SphereGeometry(0.02, 4, 4);
                const material = new THREE.MeshBasicMaterial({ color: color });
                const particle = new THREE.Mesh(geometry, material);
                
                particle.position.set(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                );
                
                particles.add(particle);
            }
            
            return particles;
        }
        
        // Configuraciones avanzadas
        const CONFIG = {
            DETECTION_INTERVAL: 500,
            SPAWN_PROBABILITY: 0.02,
            MAX_POKEMON: 20,
            SURFACE_CONFIDENCE_THRESHOLD: 0.6,
            CATCH_RADIUS: 100
        };
        
        // Sistema de puntuaci√≥n
        let score = 0;
        let combo = 0;
        
        function updateScore(points) {
            score += points * (combo + 1);
            combo++;
            
            setTimeout(() => {
                combo = Math.max(0, combo - 1);
            }, 5000);
        }
        
        console.log('üéÆ AR Pok√©mon System Loaded');
        console.log('üì± Optimizado para dispositivos m√≥viles');
        console.log('üéØ Sistema de detecci√≥n avanzado activado');
    </script>
</body>
