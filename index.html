<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR sin WebGL - Detecci√≥n de Superficies</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: #000;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
        }
        
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 15px;
            font-size: 14px;
            max-width: 280px;
            backdrop-filter: blur(10px);
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            width: 40px;
            height: 40px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
        }
        
        #crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
        }
        
        #controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .control-btn {
            background: rgba(255, 255, 255, 0.9);
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            font-size: 12px;
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 1);
            transform: scale(1.05);
        }
        
        .control-btn.active {
            background: #4CAF50;
            color: white;
        }
        
        #placeBtn {
            background: #FF6B6B;
            color: white;
            font-size: 16px;
            padding: 15px 30px;
            margin: 10px;
        }
        
        #placeBtn:hover {
            background: #FF5252;
        }
        
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 998;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }
        
        .surface-indicator {
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(76, 175, 80, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 500;
            animation: surfacePulse 1.5s infinite;
        }
        
        @keyframes surfacePulse {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.5); opacity: 0.4; }
            100% { transform: scale(1); opacity: 0.8; }
        }

        #permissionDialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .dialog-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 400px;
            margin: 20px;
        }

        .dialog-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px;
        }

        .virtual-object {
            position: absolute;
            pointer-events: none;
            z-index: 300;
            transition: all 0.3s ease;
        }

        .object-cube {
            width: 60px;
            height: 60px;
            background: linear-gradient(45deg, #4CC3D9, #2E8B9B);
            border: 2px solid #fff;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            animation: float 3s ease-in-out infinite;
        }

        .object-sphere {
            width: 60px;
            height: 60px;
            background: radial-gradient(circle at 30% 30%, #FF6B9D, #EF2D5E);
            border: 2px solid #fff;
            border-radius: 50%;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            animation: float 3s ease-in-out infinite;
        }

        .object-pyramid {
            width: 0;
            height: 0;
            border-left: 30px solid transparent;
            border-right: 30px solid transparent;
            border-bottom: 60px solid #FFC65D;
            filter: drop-shadow(0 5px 10px rgba(0,0,0,0.3));
            animation: float 3s ease-in-out infinite;
        }

        .object-pokemon {
            width: 80px;
            height: 80px;
            background: #FFD700;
            border-radius: 50%;
            position: relative;
            border: 2px solid #fff;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            animation: float 3s ease-in-out infinite;
        }

        .object-pokemon::before {
            content: '‚ö°';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
        }

        .object-pokemon::after {
            content: '';
            position: absolute;
            top: -15px;
            left: -10px;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 20px solid #FFD700;
            transform: rotate(-20deg);
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-10px) rotate(2deg); }
        }

        .placed-object {
            animation: placeAnimation 0.5s ease-out;
        }

        @keyframes placeAnimation {
            0% { transform: scale(0) rotate(0deg); opacity: 0; }
            50% { transform: scale(1.2) rotate(180deg); opacity: 0.8; }
            100% { transform: scale(1) rotate(360deg); opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="permissionDialog">
        <div class="dialog-content">
            <h2>üì∑ Acceso a la C√°mara</h2>
            <p>Esta aplicaci√≥n funciona sin WebGL y es compatible con todos los navegadores.</p>
            <p>Haz clic en "Permitir" cuando tu navegador solicite acceso a la c√°mara.</p>
            <button class="dialog-btn" onclick="requestCamera()">üöÄ Iniciar AR</button>
        </div>
    </div>

    <div id="container" style="display: none;">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="overlay"></canvas>
        
        <div id="ui">
            <h3>üéØ AR Compatible</h3>
            <p><strong>Funciona sin WebGL:</strong></p>
            <ul>
                <li>Compatible con todos los navegadores</li>
                <li>Mueve la c√°mara lentamente</li>
                <li>Busca superficies planas</li>
                <li>Toca "Colocar" cuando veas puntos verdes</li>
            </ul>
            <p><small>Estado: <span id="status">Iniciando...</span></small></p>
        </div>
        
        <div id="crosshair"></div>
        
        <div id="instructions">
            <h3>üì± Mueve tu dispositivo</h3>
            <p>Apunta la c√°mara hacia superficies como:</p>
            <ul style="text-align: left;">
                <li>Mesa o escritorio</li>
                <li>Suelo</li>
                <li>Libros o revistas</li>
                <li>Cualquier superficie plana</li>
            </ul>
            <p><small>Los puntos verdes indican superficies detectadas</small></p>
        </div>
        
        <div id="controls">
            <button class="control-btn active" onclick="changeModel('cube')">üé≤ Cubo</button>
            <button class="control-btn" onclick="changeModel('sphere')">‚öΩ Esfera</button>
            <button class="control-btn" onclick="changeModel('pyramid')">üî∫ Pir√°mide</button>
            <button class="control-btn" onclick="changeModel('pokemon')">‚ö° Pok√©mon</button>
            <button id="placeBtn" class="control-btn" onclick="placeObject()">üìç Colocar Objeto</button>
            <button class="control-btn" onclick="clearObjects()">üóëÔ∏è Limpiar</button>
        </div>
    </div>

    <script>
        // Variables globales
        let video, overlay, ctx;
        let currentModel = 'cube';
        let surfacePoints = [];
        let isTracking = false;
        let placedObjects = [];
        let isInitialized = false;
        let objectCounter = 0;
        
        // Solicitar permiso de c√°mara
        async function requestCamera() {
            try {
                document.getElementById('permissionDialog').style.display = 'none';
                document.getElementById('container').style.display = 'block';
                await init();
            } catch (error) {
                console.error('Error al solicitar c√°mara:', error);
                alert('Error al acceder a la c√°mara. Por favor, recarga la p√°gina y permite el acceso.');
            }
        }

        // Inicializar la aplicaci√≥n
        async function init() {
            if (isInitialized) return;
            
            try {
                updateStatus('Iniciando c√°mara...');
                
                // Configurar elementos
                video = document.getElementById('video');
                overlay = document.getElementById('overlay');
                ctx = overlay.getContext('2d');
                
                // Configurar canvas overlay
                overlay.width = window.innerWidth;
                overlay.height = window.innerHeight;
                
                // Solicitar acceso a la c√°mara
                const constraints = {
                    video: { 
                        facingMode: { ideal: 'environment' },
                        width: { ideal: 1280, max: 1920 },
                        height: { ideal: 720, max: 1080 }
                    },
                    audio: false
                };
                
                updateStatus('Solicitando acceso a c√°mara...');
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                
                video.srcObject = stream;
                
                // Esperar a que el video est√© listo
                video.onloadedmetadata = () => {
                    video.play().then(() => {
                        updateStatus('‚úÖ C√°mara iniciada - Busca superficies');
                        document.getElementById('instructions').style.display = 'block';
                        
                        // Iniciar detecci√≥n de superficies
                        startSurfaceDetection();
                        
                        isInitialized = true;
                    }).catch(error => {
                        console.error('Error al reproducir video:', error);
                        updateStatus('‚ùå Error al iniciar video');
                    });
                };
                
            } catch (error) {
                console.error('Error en init:', error);
                updateStatus('‚ùå Error al acceder a la c√°mara');
                
                // Mostrar mensaje de error m√°s detallado
                if (error.name === 'NotAllowedError') {
                    alert('Acceso a la c√°mara denegado. Por favor, permite el acceso y recarga la p√°gina.');
                } else if (error.name === 'NotFoundError') {
                    alert('No se encontr√≥ ninguna c√°mara. Aseg√∫rate de que tu dispositivo tenga una c√°mara.');
                } else {
                    alert('Error al acceder a la c√°mara: ' + error.message);
                }
            }
        }
        
        // Detecci√≥n de superficies mejorada
        function startSurfaceDetection() {
            setInterval(() => {
                if (video && video.readyState === video.HAVE_ENOUGH_DATA) {
                    detectSurfaces();
                }
            }, 400);
        }
        
        // Detectar superficies usando an√°lisis de imagen
        function detectSurfaces() {
            if (!video || !video.videoWidth || !video.videoHeight) return;
            
            // Limpiar puntos anteriores
            clearSurfaceIndicators();
            surfacePoints = [];
            
            try {
                // Crear canvas temporal para an√°lisis
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = Math.min(video.videoWidth, 160);
                tempCanvas.height = Math.min(video.videoHeight, 120);
                
                // Dibujar video en canvas temporal
                tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);
                
                // Obtener datos de imagen
                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const data = imageData.data;
                
                // An√°lisis de superficies basado en gradientes
                const gridSize = 15;
                const threshold = 25;
                
                for (let y = gridSize; y < tempCanvas.height - gridSize; y += gridSize) {
                    for (let x = gridSize; x < tempCanvas.width - gridSize; x += gridSize) {
                        // Calcular gradiente en la regi√≥n
                        let gradient = calculateGradient(data, x, y, gridSize, tempCanvas.width);
                        
                        // Si el gradiente es bajo, podr√≠a ser una superficie plana
                        if (gradient < threshold && Math.random() > 0.7) {
                            // Convertir coordenadas de canvas a pantalla
                            const screenX = (x / tempCanvas.width) * window.innerWidth;
                            const screenY = (y / tempCanvas.height) * window.innerHeight;
                            
                            surfacePoints.push({ 
                                x: screenX, 
                                y: screenY, 
                                confidence: 1 - (gradient / threshold),
                                time: Date.now()
                            });
                            showSurfaceIndicator(screenX, screenY);
                        }
                    }
                }
                
                // A√±adir puntos simulados si no se detectan suficientes
                if (surfacePoints.length < 2) {
                    addSimulatedSurfaces();
                }
                
                if (surfacePoints.length > 0) {
                    updateStatus(`üü¢ ${surfacePoints.length} superficie(s) detectada(s)`);
                    document.getElementById('instructions').style.display = 'none';
                    isTracking = true;
                } else {
                    updateStatus('üîç Buscando superficies...');
                    if (placedObjects.length === 0) {
                        document.getElementById('instructions').style.display = 'block';
                    }
                    isTracking = false;
                }
                
            } catch (error) {
                console.error('Error en detecci√≥n:', error);
                addSimulatedSurfaces();
            }
        }
        
        // Calcular gradiente para detectar bordes
        function calculateGradient(data, centerX, centerY, size, width) {
            const halfSize = Math.floor(size / 2);
            let totalGradient = 0;
            let count = 0;
            
            for (let dy = -halfSize + 1; dy < halfSize; dy++) {
                for (let dx = -halfSize + 1; dx < halfSize; dx++) {
                    const x1 = centerX + dx;
                    const y1 = centerY + dy;
                    const x2 = x1 + 1;
                    const y2 = y1 + 1;
                    
                    const index1 = (y1 * width + x1) * 4;
                    const index2 = (y2 * width + x2) * 4;
                    
                    if (index1 >= 0 && index2 < data.length - 3) {
                        // Calcular diferencia de luminancia
                        const lum1 = data[index1] * 0.299 + data[index1 + 1] * 0.587 + data[index1 + 2] * 0.114;
                        const lum2 = data[index2] * 0.299 + data[index2 + 1] * 0.587 + data[index2 + 2] * 0.114;
                        
                        totalGradient += Math.abs(lum1 - lum2);
                        count++;
                    }
                }
            }
            
            return count > 0 ? totalGradient / count : 100;
        }
        
        // A√±adir superficies simuladas
        function addSimulatedSurfaces() {
            for (let i = 0; i < 3; i++) {
                if (Math.random() > 0.4) {
                    const x = 100 + Math.random() * (window.innerWidth - 200);
                    const y = window.innerHeight * 0.4 + Math.random() * window.innerHeight * 0.3;
                    
                    surfacePoints.push({ 
                        x, 
                        y, 
                        confidence: 0.7 + Math.random() * 0.3,
                        time: Date.now()
                    });
                    showSurfaceIndicator(x, y);
                }
            }
        }
        
        // Mostrar indicador de superficie
        function showSurfaceIndicator(x, y) {
            const indicator = document.createElement('div');
            indicator.className = 'surface-indicator';
            indicator.style.left = (x - 10) + 'px';
            indicator.style.top = (y - 10) + 'px';
            document.getElementById('container').appendChild(indicator);
            
            // Remover despu√©s de 2 segundos
            setTimeout(() => {
                if (indicator && indicator.parentNode) {
                    indicator.parentNode.removeChild(indicator);
                }
            }, 2000);
        }
        
        // Limpiar indicadores de superficie
        function clearSurfaceIndicators() {
            const indicators = document.querySelectorAll('.surface-indicator');
            indicators.forEach(indicator => {
                if (indicator.parentNode) {
                    indicator.parentNode.removeChild(indicator);
                }
            });
        }
        
        // Crear objeto virtual 2D
        function createVirtualObject(type, x, y) {
            const object = document.createElement('div');
            object.className = `virtual-object object-${type} placed-object`;
            object.style.left = (x - 30) + 'px';
            object.style.top = (y - 30) + 'px';
            
            // A√±adir datos del objeto
            object.dataset.type = type;
            object.dataset.id = 'obj_' + (++objectCounter);
            object.dataset.createdAt = Date.now();
            
            // A√±adir efecto de rotaci√≥n aleatoria
            const randomRotation = Math.random() * 360;
            object.style.transform = `rotate(${randomRotation}deg)`;
            
            return object;
        }
        
        // Colocar objeto en superficie
        function placeObject() {
            if (!isTracking || surfacePoints.length === 0) {
                updateStatus('‚ùå No hay superficies detectadas');
                return;
            }
            
            // Encontrar el mejor punto para colocar el objeto
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            
            let bestPoint = surfacePoints[0];
            let bestScore = 0;
            
            surfacePoints.forEach(point => {
                const distance = Math.sqrt(
                    Math.pow(point.x - centerX, 2) + 
                    Math.pow(point.y - centerY, 2)
                );
                const normalizedDistance = 1 - (distance / Math.sqrt(centerX * centerX + centerY * centerY));
                const ageBonus = 1 - Math.min((Date.now() - point.time) / 5000, 0.5); // Prefiere puntos m√°s recientes
                const score = (point.confidence || 0.5) * 0.4 + normalizedDistance * 0.4 + ageBonus * 0.2;
                
                if (score > bestScore) {
                    bestScore = score;
                    bestPoint = point;
                }
            });
            
            // Crear y colocar el objeto
            const virtualObject = createVirtualObject(currentModel, bestPoint.x, bestPoint.y);
            document.getElementById('container').appendChild(virtualObject);
            placedObjects.push(virtualObject);
            
            updateStatus(`‚úÖ ${getModelName(currentModel)} colocado!`);
            
            // Efecto sonoro simulado con vibraci√≥n (si est√° disponible)
            if (navigator.vibrate) {
                navigator.vibrate(100);
            }
        }
        
        // Cambiar modelo actual
        function changeModel(modelType) {
            document.querySelectorAll('.control-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            currentModel = modelType;
            updateStatus(`Modelo seleccionado: ${getModelName(modelType)}`);
        }
        
        // Limpiar todos los objetos
        function clearObjects() {
            placedObjects.forEach(obj => {
                if (obj.parentNode) {
                    obj.parentNode.removeChild(obj);
                }
            });
            placedObjects = [];
            objectCounter = 0;
            updateStatus('üóëÔ∏è Objetos eliminados');
        }
        
        // Obtener nombre del modelo
        function getModelName(type) {
            const names = {
                'cube': 'Cubo M√°gico',
                'sphere': 'Esfera Brillante',
                'pyramid': 'Pir√°mide Dorada',
                'pokemon': 'Pikachu'
            };
            return names[type] || type;
        }
        
        // Actualizar estado
        function updateStatus(message) {
            const statusEl = document.getElementById('status');
            if (statusEl) {
                statusEl.textContent = message;
            }
        }
        
        // Manejar redimensionado
        window.addEventListener('resize', () => {
            if (overlay) {
                overlay.width = window.innerWidth;
                overlay.height = window.innerHeight;
            }
        });
        
        // Verificar soporte de navegador
        function checkBrowserSupport() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                alert('Tu navegador no soporta acceso a la c√°mara. Usa Chrome, Firefox o Safari m√°s reciente.');
                return false;
            }
            return true;
        }
        
        // Inicializar cuando se carga la p√°gina
        window.addEventListener('load', () => {
            if (checkBrowserSupport()) {
                updateStatus('Listo para iniciar');
            }
        });

        // A√±adir interactividad a objetos colocados
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('virtual-object')) {
                // Efecto de click en objeto
                e.target.style.animation = 'none';
                setTimeout(() => {
                    e.target.style.animation = 'float 3s ease-in-out infinite';
                }, 10);
                
                // Cambiar color temporalmente
                const originalFilter = e.target.style.filter;
                e.target.style.filter = 'brightness(1.5) saturate(1.5)';
                setTimeout(() => {
                    e.target.style.filter = originalFilter;
                }, 200);
            }
        });
    </script>
</body>
</html>
