<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Surface Scanner - M√≥vil</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #000;
            user-select: none;
            touch-action: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
            transform: scaleX(-1); /* Efecto espejo para c√°mara frontal */
        }
        
        #threejs-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }
        
        #click-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            cursor: crosshair;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 12px 15px;
            border-radius: 12px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            font-size: 14px;
            pointer-events: none;
        }
        
        .corner-point {
            position: absolute;
            width: 30px;
            height: 30px;
            border: 4px solid #00ff00;
            border-radius: 50%;
            background: rgba(0, 255, 0, 0.3);
            z-index: 500;
            pointer-events: none;
            animation: cornerPulse 1.5s infinite;
            box-shadow: 0 0 25px #00ff00;
            transform: translate(-50%, -50%);
        }
        
        .corner-point.confirmed {
            border-color: #ff0080;
            background: rgba(255, 0, 128, 0.3);
            box-shadow: 0 0 25px #ff0080;
            animation: confirmedPulse 1s infinite;
        }
        
        .corner-point.tracking {
            border-color: #ffff00;
            background: rgba(255, 255, 0, 0.4);
            box-shadow: 0 0 30px #ffff00;
            animation: trackingPulse 0.6s infinite;
        }
        
        @keyframes cornerPulse {
            0%, 100% { 
                transform: translate(-50%, -50%) scale(1); 
                opacity: 0.8; 
            }
            50% { 
                transform: translate(-50%, -50%) scale(1.2); 
                opacity: 1; 
            }
        }
        
        @keyframes confirmedPulse {
            0%, 100% { 
                transform: translate(-50%, -50%) scale(1) rotate(0deg); 
                opacity: 0.9; 
            }
            50% { 
                transform: translate(-50%, -50%) scale(1.15) rotate(180deg); 
                opacity: 1; 
            }
        }
        
        @keyframes trackingPulse {
            0%, 100% { 
                transform: translate(-50%, -50%) scale(1); 
                opacity: 1; 
            }
            50% { 
                transform: translate(-50%, -50%) scale(1.3); 
                opacity: 0.7; 
            }
        }
        
        .surface-outline {
            position: absolute;
            border: 3px solid #00ffff;
            z-index: 400;
            pointer-events: none;
            background: rgba(0, 255, 255, 0.08);
            border-radius: 8px;
            animation: surfaceGlow 2s infinite;
        }
        
        @keyframes surfaceGlow {
            0%, 100% { 
                box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
                border-color: #00ffff;
            }
            50% { 
                box-shadow: 0 0 40px rgba(0, 255, 255, 0.9);
                border-color: #00ff88;
            }
        }
        
        .corner-label {
            position: absolute;
            top: -40px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 11px;
            font-weight: bold;
            white-space: nowrap;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        #crosshair {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            z-index: 600;
            pointer-events: none;
            display: none;
            transform: translate(-50%, -50%);
            animation: crosshairPulse 1s infinite;
        }
        
        @keyframes crosshairPulse {
            0%, 100% { opacity: 0.7; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
        }
        
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
        }
        
        #crosshair::before {
            top: 50%;
            left: 20%;
            width: 60%;
            height: 3px;
            transform: translateY(-50%);
        }
        
        #crosshair::after {
            left: 50%;
            top: 20%;
            width: 3px;
            height: 60%;
            transform: translateX(-50%);
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            justify-content: center;
            gap: 10px;
            pointer-events: auto;
            flex-wrap: wrap;
        }
        
        .control-btn {
            background: rgba(255, 255, 255, 0.95);
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            font-size: 13px;
            min-height: 45px;
            flex: 1;
            max-width: 120px;
        }
        
        .control-btn:active {
            transform: scale(0.95);
        }
        
        .control-btn.primary {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
        }
        
        .control-btn.place {
            background: linear-gradient(45deg, #2196F3, #1976D2);
            color: white;
        }
        
        .control-btn.danger {
            background: linear-gradient(45deg, #f44336, #da190b);
            color: white;
        }
        
        .control-btn.tracking {
            background: linear-gradient(45deg, #FF9800, #F57C00);
            color: white;
            animation: trackingBtn 1s infinite;
        }
        
        @keyframes trackingBtn {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        #permissionDialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .dialog-content {
            background: rgba(255, 255, 255, 0.95);
            padding: 30px 25px;
            border-radius: 20px;
            text-align: center;
            max-width: 380px;
            width: 100%;
            backdrop-filter: blur(20px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
        }
        
        .dialog-btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            width: 100%;
            margin-top: 15px;
        }
        
        .dialog-btn:active {
            transform: scale(0.95);
        }
        
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 998;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 25px 20px;
            border-radius: 20px;
            text-align: center;
            max-width: 350px;
            width: calc(100% - 40px);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            margin: 8px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00ffff);
            border-radius: 3px;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .click-hint {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: bold;
            animation: clickHint 2s infinite;
            z-index: 700;
            pointer-events: none;
            max-width: 140px;
            text-align: center;
        }
        
        @keyframes clickHint {
            0%, 100% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.02); }
        }
        
        .tracking-indicator {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 152, 0, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            z-index: 999;
            display: none;
            animation: trackingIndicator 1s infinite;
        }
        
        @keyframes trackingIndicator {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        /* Mejoras para m√≥vil */
        @media (max-width: 480px) {
            #ui {
                font-size: 12px;
                padding: 10px 12px;
            }
            
            .control-btn {
                font-size: 11px;
                padding: 10px 15px;
                min-height: 40px;
            }
            
            .corner-point {
                width: 35px;
                height: 35px;
                border-width: 5px;
            }
            
            .corner-label {
                font-size: 10px;
                padding: 4px 8px;
            }
            
            #instructions {
                padding: 20px 15px;
                font-size: 14px;
            }
        }
        
        /* Prevenir scroll en m√≥vil */
        html, body {
            height: 100%;
            overflow: hidden;
            position: fixed;
            width: 100%;
        }
    </style>
</head>
<body>
    <div id="permissionDialog">
        <div class="dialog-content">
            <h2>üì± Scanner AR M√≥vil</h2>
            <p><strong>Marca 4 puntos para crear una superficie persistente</strong></p>
            <p>üéØ Toca las 4 esquinas de la superficie</p>
            <p>üìç Los puntos se mantendr√°n fijos</p>
            <p>üì¶ El objeto permanecer√° en su lugar</p>
            <p>üîÑ Mueve la c√°mara y vuelve - ¬°el objeto seguir√° ah√≠!</p>
            <button class="dialog-btn" onclick="requestCamera()">üöÄ Iniciar Scanner</button>
        </div>
    </div>
    
    <div id="container" style="display: none;">
        <video id="video" autoplay muted playsinline></video>
        <div id="threejs-container"></div>
        <div id="click-overlay"></div>
        <div id="crosshair"></div>
        
        <div class="tracking-indicator" id="trackingIndicator">
            üéØ Superficie en seguimiento
        </div>
        
        <div id="ui">
            <h3>üì± Scanner AR</h3>
            <p><strong>Estado:</strong> <span id="status">Iniciando...</span></p>
            <p><strong>Puntos:</strong> <span id="cornerCount">0/4</span> | <strong>Tracking:</strong> <span id="trackingStatus">Inactivo</span></p>
            <div class="progress-bar">
                <div class="progress-fill" id="scanProgress"></div>
            </div>
        </div>
        
        <div id="instructions">
            <h3>üéØ Crear Superficie AR</h3>
            <p><strong>Toca las 4 esquinas en orden:</strong></p>
            <div style="text-align: left; margin: 15px 0; font-size: 13px;">
                <p>1Ô∏è‚É£ Esquina superior izquierda</p>
                <p>2Ô∏è‚É£ Esquina superior derecha</p>
                <p>3Ô∏è‚É£ Esquina inferior derecha</p>
                <p>4Ô∏è‚É£ Esquina inferior izquierda</p>
            </div>
            <p><small>Una vez marcada, la superficie se mantendr√° fija</small></p>
        </div>
        
        <div id="controls">
            <button class="control-btn primary" onclick="undoLastPoint()">‚Ü∂ Deshacer</button>
            <button class="control-btn place" onclick="placeObject()" disabled>üì¶ Objeto</button>
            <button class="control-btn danger" onclick="resetPoints()">üîÑ Reset</button>
            <button class="control-btn tracking" onclick="toggleTracking()" id="trackingBtn" style="display: none;">üéØ Track</button>
        </div>
    </div>

    <script>
        // Variables globales
        let video, scene, camera, renderer;
        let manualCorners = [];
        let surfaceOutline = null;
        let placedObjects = [];
        let isInitialized = false;
        let detectedSurface = null;
        let animationId;
        let clickOverlay;
        let crosshair;
        let isTracking = false;
        let trackingData = null;
        let deviceOrientation = { alpha: 0, beta: 0, gamma: 0 };
        let devicePosition = { x: 0, y: 0, z: 0 };
        let surfaceTransform = null;
        let videoWidth = 0;
        let videoHeight = 0;
        
        // Inicializar Three.js con configuraci√≥n para m√≥vil
        function initThreeJS() {
            const container = document.getElementById('threejs-container');
            
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(
                75, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                1000
            );
            camera.position.set(0, 2, 5);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ 
                alpha: true, 
                antialias: false, // Optimizaci√≥n para m√≥vil
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limitar para performance
            renderer.setClearColor(0x000000, 0);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            container.appendChild(renderer.domElement);
            
            // Luces optimizadas
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(3, 6, 3);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024; // Reducido para m√≥vil
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);
            
            // Superficie de referencia invisible
            const planeGeometry = new THREE.PlaneGeometry(10, 10);
            const planeMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x888888, 
                transparent: true, 
                opacity: 0 
            });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.receiveShadow = true;
            scene.add(plane);
            
            // Inicializar sensores de dispositivo
            initDeviceSensors();
            
            animate();
        }
        
        // Inicializar sensores del dispositivo
        function initDeviceSensors() {
            // Solicitar permisos para sensores en iOS
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            window.addEventListener('deviceorientation', handleDeviceOrientation);
                        }
                    })
                    .catch(console.error);
            } else {
                window.addEventListener('deviceorientation', handleDeviceOrientation);
            }
            
            // Detectar movimiento del dispositivo
            if ('DeviceMotionEvent' in window) {
                window.addEventListener('devicemotion', handleDeviceMotion);
            }
        }
        
        // Manejar orientaci√≥n del dispositivo
        function handleDeviceOrientation(event) {
            deviceOrientation = {
                alpha: event.alpha || 0,  // Rotaci√≥n Z
                beta: event.beta || 0,    // Rotaci√≥n X
                gamma: event.gamma || 0   // Rotaci√≥n Y
            };
            
            // Actualizar tracking si est√° activo
            if (isTracking && trackingData) {
                updateSurfaceTracking();
            }
        }
        
        // Manejar movimiento del dispositivo
        function handleDeviceMotion(event) {
            if (event.acceleration) {
                devicePosition.x += (event.acceleration.x || 0) * 0.01;
                devicePosition.y += (event.acceleration.y || 0) * 0.01;
                devicePosition.z += (event.acceleration.z || 0) * 0.01;
            }
        }
        
        // Solicitar permiso de c√°mara
        async function requestCamera() {
            try {
                document.getElementById('permissionDialog').style.display = 'none';
                document.getElementById('container').style.display = 'block';
                await init();
            } catch (error) {
                console.error('Error al solicitar c√°mara:', error);
                alert('Error al acceder a la c√°mara. Por favor, recarga y permite el acceso.');
            }
        }
        
        // Inicializar la aplicaci√≥n
        async function init() {
            if (isInitialized) return;
            
            try {
                updateStatus('Iniciando c√°mara...');
                
                video = document.getElementById('video');
                clickOverlay = document.getElementById('click-overlay');
                crosshair = document.getElementById('crosshair');
                
                initThreeJS();
                setupEventListeners();
                
                const constraints = {
                    video: { 
                        facingMode: { ideal: 'environment' }, // C√°mara trasera preferida
                        width: { ideal: 1280, max: 1920 },
                        height: { ideal: 720, max: 1080 }
                    },
                    audio: false
                };
                
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                
                video.onloadedmetadata = () => {
                    videoWidth = video.videoWidth;
                    videoHeight = video.videoHeight;
                    
                    video.play().then(() => {
                        updateStatus('‚úÖ Listo para marcar superficie');
                        isInitialized = true;
                        showClickHints();
                    });
                };
                
            } catch (error) {
                console.error('Error en init:', error);
                updateStatus('‚ùå Error al acceder a la c√°mara');
            }
        }
        
        // Configurar eventos optimizados para m√≥vil
        function setupEventListeners() {
            // Eventos t√°ctiles optimizados
            clickOverlay.addEventListener('touchstart', handleTouch, { passive: false });
            clickOverlay.addEventListener('touchmove', handleTouchMove, { passive: false });
            clickOverlay.addEventListener('touchend', handleTouchEnd, { passive: false });
            
            // Fallback para mouse (testing en desktop)
            clickOverlay.addEventListener('mousedown', handleClick);
            clickOverlay.addEventListener('mousemove', showCrosshair);
            clickOverlay.addEventListener('mouseleave', hideCrosshair);
            
            // Prevenir comportamientos por defecto en m√≥vil
            document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
            document.addEventListener('touchstart', (e) => {
                if (e.touches.length > 1) e.preventDefault();
            }, { passive: false });
        }
        
        let touchStartTime = 0;
        let touchStartPos = null;
        
        // Manejar inicio de toque
        function handleTouch(event) {
            event.preventDefault();
            touchStartTime = Date.now();
            
            const rect = clickOverlay.getBoundingClientRect();
            const touch = event.touches[0];
            touchStartPos = {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
            
            // Mostrar crosshair en la posici√≥n del toque
            showCrosshairAt(touchStartPos.x, touchStartPos.y);
        }
        
        // Manejar movimiento del toque
        function handleTouchMove(event) {
            event.preventDefault();
            
            if (touchStartPos) {
                const rect = clickOverlay.getBoundingClientRect();
                const touch = event.touches[0];
                const currentPos = {
                    x: touch.clientX - rect.left,
                    y: touch.clientY - rect.top
                };
                
                // Actualizar posici√≥n del crosshair
                showCrosshairAt(currentPos.x, currentPos.y);
            }
        }
        
        // Manejar fin de toque
        function handleTouchEnd(event) {
            event.preventDefault();
            
            const touchDuration = Date.now() - touchStartTime;
            
            // Solo registrar como tap si fue un toque r√°pido
            if (touchDuration < 300 && touchStartPos) {
                addManualPoint(touchStartPos.x, touchStartPos.y);
            }
            
            touchStartPos = null;
            hideCrosshair();
        }
        
        // Manejar clic (para testing en desktop)
        function handleClick(event) {
            event.preventDefault();
            const rect = clickOverlay.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            addManualPoint(x, y);
        }
        
        // Mostrar crosshair en posici√≥n espec√≠fica
        function showCrosshairAt(x, y) {
            if (manualCorners.length >= 4) return;
            
            crosshair.style.left = x + 'px';
            crosshair.style.top = y + 'px';
            crosshair.style.display = 'block';
        }
        
        // Mostrar crosshair (mouse)
        function showCrosshair(event) {
            if (manualCorners.length >= 4) return;
            
            const rect = clickOverlay.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            showCrosshairAt(x, y);
        }
        
        // Ocultar crosshair
        function hideCrosshair() {
            crosshair.style.display = 'none';
        }
        
        // Agregar punto manual con tracking
        function addManualPoint(x, y) {
            if (manualCorners.length >= 4) {
                showMessage('‚úÖ Ya tienes los 4 puntos marcados', 'info');
                return;
            }
            
            const point = { 
                x, 
                y, 
                screenX: x / window.innerWidth,
                screenY: y / window.innerHeight,
                deviceOrientation: { ...deviceOrientation },
                timestamp: Date.now()
            };
            
            manualCorners.push(point);
            
            showCornerPoint(point, manualCorners.length - 1);
            updateCornerCount(manualCorners.length);
            updateScanProgress((manualCorners.length / 4) * 100);
            
            // Feedback t√°ctil si est√° disponible
            if (navigator.vibrate) {
                navigator.vibrate(50);
            }
            
            createClickFeedback(x, y);
            
            updateStatus(`üìç Punto ${manualCorners.length}/4 marcado`);
            
            if (manualCorners.length === 4) {
                completeSurface();
            } else {
                const nextCorner = ['superior derecha', 'inferior derecha', 'inferior izquierda'][manualCorners.length - 1];
                showClickHint(x, y, `Siguiente: ${nextCorner}`);
            }
        }
        
        // Completar superficie con tracking
        function completeSurface() {
            hideCrosshair();
            
            // Limpiar hints existentes
            clearClickHints();
            
            // Marcar puntos como confirmados
            const cornerPoints = document.querySelectorAll('.corner-point');
            cornerPoints.forEach(point => {
                point.classList.add('confirmed');
            });
            
            // Crear datos de tracking
            trackingData = {
                corners: [...manualCorners],
                referenceOrientation: { ...deviceOrientation },
                referencePosition: { ...devicePosition },
                screenDimensions: {
                    width: window.innerWidth,
                    height: window.innerHeight
                },
                videoResolution: {
                    width: videoWidth,
                    height: videoHeight
                }
            };
            
            // Mostrar contorno de superficie
            showSurfaceOutline(manualCorners);
            
            // Crear superficie detectada
            detectedSurface = {
                corners: manualCorners,
                center: calculateCenter(manualCorners),
                confirmed: true,
                manual: true,
                trackingData: trackingData
            };
            
            updateStatus('‚úÖ Superficie AR creada');
            updateTrackingStatus('Superficie fija');
            
            // Ocultar instrucciones
            document.getElementById('instructions').style.display = 'none';
            
            // Mostrar bot√≥n de tracking
            document.getElementById('trackingBtn').style.display = 'block';
            
            // Habilitar bot√≥n de colocar objeto
            document.querySelector('.control-btn.place').disabled = false;
            
            // Mostrar mensaje de √©xito
            showMessage('üéØ Superficie AR lista. ¬°Puedes colocar objetos!', 'success');
            
            // Iniciar tracking autom√°tico
            startTracking();
        }
        
        // Iniciar tracking de superficie
        function startTracking() {
            if (!trackingData) return;
            
            isTracking = true;
            document.getElementById('trackingIndicator').style.display = 'block';
            document.getElementById('trackingBtn').textContent = '‚èπ Stop';
            document.getElementById('trackingBtn').classList.add('tracking');
            
            updateTrackingStatus('Activo');
            
            // Marcar puntos como en tracking
            const cornerPoints = document.querySelectorAll('.corner-point');
            cornerPoints.forEach(point => {
                point.classList.add('tracking');
            });
        }
        
        // Detener tracking
        function stopTracking() {
            isTracking = false;
            document.getElementById('trackingIndicator').style.display = 'none';
            document.getElementById('trackingBtn').textContent = 'üéØ Track';
            document.getElementById('trackingBtn').classList.remove('tracking');
            
            updateTrackingStatus('Inactivo');
            
            // Remover clase de tracking de puntos
            const cornerPoints = document.querySelectorAll('.corner-point');
            cornerPoints.forEach(point => {
                point.classList.remove('tracking');
            });
        }
        
        // Toggle tracking
        function toggleTracking() {
            if (!trackingData) {
                showMessage('‚ö† No hay superficie para hacer tracking', 'warning');
                return;
            }
            
            if (isTracking) {
                stopTracking();
            } else {
                startTracking();
            }
        }
        
        // Actualizar tracking de superficie basado en sensores
        function updateSurfaceTracking() {
            if (!isTracking || !trackingData || !detectedSurface) return;
            
            // Calcular diferencias de orientaci√≥n
            const orientationDiff = {
                alpha: deviceOrientation.alpha - trackingData.referenceOrientation.alpha,
                beta: deviceOrientation.beta - trackingData.referenceOrientation.beta,
                gamma: deviceOrientation.gamma - trackingData.referenceOrientation.gamma
            };
            
            // Calcular nuevas posiciones de los puntos basadas en el movimiento
            const updatedCorners = trackingData.corners.map((corner, index) => {
                // Ajuste b√°sico basado en la orientaci√≥n del dispositivo
                const adjustmentX = orientationDiff.gamma * 2; // Rotaci√≥n Y -> movimiento X
                const adjustmentY = orientationDiff.beta * 2;  // Rotaci√≥n X -> movimiento Y
                
                return {
                    ...corner,
                    x: corner.x + adjustmentX,
                    y: corner.y + adjustmentY,
                    adjusted: true
                };
            });
            
            // Actualizar posiciones de los puntos visuales
            updateCornerPositions(updatedCorners);
            
            // Actualizar contorno de superficie
            updateSurfaceOutline(updatedCorners);
            
            // Actualizar posiciones de objetos colocados
            updatePlacedObjectsPositions(updatedCorners);
        }
        
        // Actualizar posiciones de los puntos de esquina
        function updateCornerPositions(corners) {
            const cornerPoints = document.querySelectorAll('.corner-point');
            corners.forEach((corner, index) => {
                if (cornerPoints[index]) {
                    cornerPoints[index].style.left = corner.x + 'px';
                    cornerPoints[index].style.top = corner.y + 'px';
                }
            });
        }
        
        // Actualizar contorno de superficie
        function updateSurfaceOutline(corners) {
            if (surfaceOutline && corners.length === 4) {
                const bounds = getBounds(corners);
                surfaceOutline.style.left = bounds.left + 'px';
                surfaceOutline.style.top = bounds.top + 'px';
                surfaceOutline.style.width = bounds.width + 'px';
                surfaceOutline.style.height = bounds.height + 'px';
            }
        }
        
        // Actualizar posiciones de objetos colocados
        function updatePlacedObjectsPositions(corners) {
            if (!detectedSurface || placedObjects.length === 0) return;
            
            const newCenter = calculateCenter(corners);
            const originalCenter = detectedSurface.center;
            
            // Calcular offset
            const offsetX = newCenter.x - originalCenter.x;
            const offsetY = newCenter.y - originalCenter.y;
            
            // Actualizar objetos 3D (esta es una simplificaci√≥n)
            placedObjects.forEach(obj => {
                if (obj.mesh) {
                    // Ajustar posici√≥n basada en el movimiento de la superficie
                    obj.mesh.position.x += offsetX * 0.01;
                    obj.mesh.position.z += offsetY * 0.01;
                }
            });
            
            // Actualizar centro de referencia
            detectedSurface.center = newCenter;
        }
        
        // Mostrar punto de esquina
        function showCornerPoint(point, index) {
            const cornerPoint = document.createElement('div');
            cornerPoint.className = 'corner-point';
            cornerPoint.style.left = point.x + 'px';
            cornerPoint.style.top = point.y + 'px';
            
            const label = document.createElement('div');
            label.className = 'corner-label';
            const cornerNames = ['Superior Izq', 'Superior Der', 'Inferior Der', 'Inferior Izq'];
            label.textContent = cornerNames[index];
            cornerPoint.appendChild(label);
            
            document.body.appendChild(cornerPoint);
            
            // Animaci√≥n de aparici√≥n
            cornerPoint.style.transform = 'translate(-50%, -50%) scale(0)';
            setTimeout(() => {
                cornerPoint.style.transform = 'translate(-50%, -50%) scale(1)';
                cornerPoint.style.transition = 'transform 0.3s ease';
            }, 50);
        }
        
        // Mostrar contorno de superficie
        function showSurfaceOutline(corners) {
            if (surfaceOutline) {
                surfaceOutline.remove();
            }
            
            const bounds = getBounds(corners);
            
            surfaceOutline = document.createElement('div');
            surfaceOutline.className = 'surface-outline';
            surfaceOutline.style.left = bounds.left + 'px';
            surfaceOutline.style.top = bounds.top + 'px';
            surfaceOutline.style.width = bounds.width + 'px';
            surfaceOutline.style.height = bounds.height + 'px';
            
            document.body.appendChild(surfaceOutline);
        }
        
        // Calcular l√≠mites de la superficie
        function getBounds(corners) {
            const xs = corners.map(c => c.x);
            const ys = corners.map(c => c.y);
            
            return {
                left: Math.min(...xs),
                top: Math.min(...ys),
                width: Math.max(...xs) - Math.min(...xs),
                height: Math.max(...ys) - Math.min(...ys)
            };
        }
        
        // Calcular centro
        function calculateCenter(corners) {
            const x = corners.reduce((sum, c) => sum + c.x, 0) / corners.length;
            const y = corners.reduce((sum, c) => sum + c.y, 0) / corners.length;
            return { x, y };
        }
        
        // Colocar objeto 3D
        function placeObject() {
            if (!detectedSurface) {
                showMessage('‚ö† Primero marca una superficie', 'warning');
                return;
            }
            
            const center = detectedSurface.center;
            
            // Crear geometr√≠a del objeto (cubo con textura)
            const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const material = new THREE.MeshLambertMaterial({ 
                color: Math.random() * 0xffffff,
                transparent: true,
                opacity: 0.9
            });
            
            const cube = new THREE.Mesh(geometry, material);
            
            // Posicionar en el centro de la superficie
            const worldPos = screenToWorld(center.x, center.y);
            cube.position.set(worldPos.x, 0.25, worldPos.z);
            cube.castShadow = true;
            cube.receiveShadow = true;
            
            // Animaci√≥n de aparici√≥n
            cube.scale.set(0, 0, 0);
            scene.add(cube);
            
            // Animar escala
            const startTime = Date.now();
            const animateScale = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / 500, 1);
                const scale = progress * (1 + Math.sin(progress * Math.PI) * 0.2);
                
                cube.scale.set(scale, scale, scale);
                
                if (progress < 1) {
                    requestAnimationFrame(animateScale);
                }
            };
            animateScale();
            
            // Agregar a la lista de objetos
            const objectData = {
                mesh: cube,
                position: { ...worldPos },
                surfacePoint: { x: center.x, y: center.y },
                timestamp: Date.now()
            };
            
            placedObjects.push(objectData);
            
            // Feedback
            if (navigator.vibrate) {
                navigator.vibrate([50, 50, 50]);
            }
            
            showMessage(`üì¶ Objeto ${placedObjects.length} colocado`, 'success');
        }
        
        // Convertir coordenadas de pantalla a mundo 3D
        function screenToWorld(screenX, screenY) {
            const x = (screenX / window.innerWidth) * 4 - 2;
            const z = (screenY / window.innerHeight) * 4 - 2;
            return { x, y: 0, z };
        }
        
        // Deshacer √∫ltimo punto
        function undoLastPoint() {
            if (manualCorners.length === 0) {
                showMessage('‚ö† No hay puntos para deshacer', 'warning');
                return;
            }
            
            manualCorners.pop();
            
            // Remover punto visual
            const cornerPoints = document.querySelectorAll('.corner-point');
            if (cornerPoints.length > 0) {
                cornerPoints[cornerPoints.length - 1].remove();
            }
            
            updateCornerCount(manualCorners.length);
            updateScanProgress((manualCorners.length / 4) * 100);
            
            if (manualCorners.length === 0) {
                updateStatus('üìç Marca la primera esquina');
                document.getElementById('instructions').style.display = 'block';
            } else {
                updateStatus(`üìç Punto deshecho. Actual: ${manualCorners.length}/4`);
            }
            
            // Si ten√≠amos 4 puntos y ahora menos, limpiar superficie
            if (manualCorners.length < 4 && detectedSurface) {
                clearSurface();
            }
        }
        
        // Resetear todos los puntos
        function resetPoints() {
            manualCorners = [];
            clearSurface();
            
            // Remover todos los puntos visuales
            document.querySelectorAll('.corner-point').forEach(point => point.remove());
            
            updateCornerCount(0);
            updateScanProgress(0);
            updateStatus('üîÑ Puntos reseteados. Marca nueva superficie');
            updateTrackingStatus('Inactivo');
            
            // Mostrar instrucciones
            document.getElementById('instructions').style.display = 'block';
            
            // Deshabilitar bot√≥n de objeto
            document.querySelector('.control-btn.place').disabled = true;
            
            // Ocultar bot√≥n de tracking
            document.getElementById('trackingBtn').style.display = 'none';
            
            // Detener tracking
            if (isTracking) {
                stopTracking();
            }
            
            showMessage('üîÑ Superficie reseteada', 'info');
        }
        
        // Limpiar superficie
        function clearSurface() {
            if (surfaceOutline) {
                surfaceOutline.remove();
                surfaceOutline = null;
            }
            
            detectedSurface = null;
            trackingData = null;
            
            // Limpiar objetos colocados
            placedObjects.forEach(obj => {
                if (obj.mesh) {
                    scene.remove(obj.mesh);
                }
            });
            placedObjects = [];
            
            document.getElementById('trackingIndicator').style.display = 'none';
        }
        
        // Crear feedback visual de clic
        function createClickFeedback(x, y) {
            const feedback = document.createElement('div');
            feedback.style.position = 'absolute';
            feedback.style.left = x + 'px';
            feedback.style.top = y + 'px';
            feedback.style.width = '60px';
            feedback.style.height = '60px';
            feedback.style.border = '3px solid #00ff00';
            feedback.style.borderRadius = '50%';
            feedback.style.transform = 'translate(-50%, -50%)';
            feedback.style.zIndex = '800';
            feedback.style.pointerEvents = 'none';
            feedback.style.animation = 'clickFeedback 0.6s ease-out forwards';
            
            document.body.appendChild(feedback);
            
            setTimeout(() => feedback.remove(), 600);
        }
        
        // Mostrar hints de clic
        function showClickHints() {
            const hint = document.createElement('div');
            hint.className = 'click-hint';
            hint.textContent = 'üëÜ Toca para marcar esquina';
            hint.style.top = '50%';
            hint.style.left = '50%';
            hint.style.transform = 'translate(-50%, -50%)';
            
            document.body.appendChild(hint);
            
            setTimeout(() => {
                if (hint.parentNode) {
                    hint.remove();
                }
            }, 4000);
        }
        
        // Mostrar hint espec√≠fico
        function showClickHint(x, y, text) {
            const hint = document.createElement('div');
            hint.className = 'click-hint';
            hint.textContent = text;
            hint.style.left = (x + 20) + 'px';
            hint.style.top = (y - 20) + 'px';
            
            document.body.appendChild(hint);
            
            setTimeout(() => {
                if (hint.parentNode) {
                    hint.remove();
                }
            }, 2000);
        }
        
        // Limpiar hints
        function clearClickHints() {
            document.querySelectorAll('.click-hint').forEach(hint => hint.remove());
        }
        
        // Mostrar mensaje
        function showMessage(text, type = 'info') {
            const message = document.createElement('div');
            message.style.position = 'fixed';
            message.style.top = '50%';
            message.style.left = '50%';
            message.style.transform = 'translate(-50%, -50%)';
            message.style.background = type === 'success' ? 'rgba(76, 175, 80, 0.95)' : 
                                     type === 'warning' ? 'rgba(255, 152, 0, 0.95)' : 
                                     'rgba(33, 150, 243, 0.95)';
            message.style.color = 'white';
            message.style.padding = '15px 25px';
            message.style.borderRadius = '25px';
            message.style.zIndex = '1500';
            message.style.fontSize = '14px';
            message.style.fontWeight = 'bold';
            message.style.textAlign = 'center';
            message.style.backdropFilter = 'blur(10px)';
            message.style.maxWidth = '80%';
            message.textContent = text;
            
            document.body.appendChild(message);
            
            setTimeout(() => {
                if (message.parentNode) {
                    message.remove();
                }
            }, 3000);
        }
        
        // Actualizar estado
        function updateStatus(status) {
            document.getElementById('status').textContent = status;
        }
        
        // Actualizar contador de esquinas
        function updateCornerCount(count) {
            document.getElementById('cornerCount').textContent = `${count}/4`;
        }
        
        // Actualizar progreso de escaneo
        function updateScanProgress(percentage) {
            document.getElementById('scanProgress').style.width = percentage + '%';
        }
        
        // Actualizar estado de tracking
        function updateTrackingStatus(status) {
            document.getElementById('trackingStatus').textContent = status;
        }
        
        // Loop de animaci√≥n
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            // Rotar objetos colocados
            placedObjects.forEach((obj, index) => {
                if (obj.mesh) {
                    obj.mesh.rotation.y += 0.01;
                    obj.mesh.rotation.x = Math.sin(Date.now() * 0.001 + index) * 0.1;
                }
            });
            
            renderer.render(scene, camera);
        }
        
        // Manejar cambio de orientaci√≥n
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                if (camera && renderer) {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
            }, 100);
        });
        
        // Agregar estilos CSS para animaciones
        const additionalStyles = `
            @keyframes clickFeedback {
                0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
                100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
            }
        `;
        
        const styleSheet = document.createElement('style');
        styleSheet.textContent = additionalStyles;
        document.head.appendChild(styleSheet);
        
        // Inicializar cuando se carga la p√°gina
        document.addEventListener('DOMContentLoaded', () => {
            console.log('AR Surface Scanner iniciado');
        });
    </script>
</body>
</html>
