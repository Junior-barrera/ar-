<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Surface Scanner - Detecci√≥n por 4 Puntos</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #000;
            user-select: none;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
        }
        
        #threejs-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 300px;
        }
        
        .corner-point {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 3px solid #00ff00;
            border-radius: 50%;
            background: rgba(0, 255, 0, 0.3);
            z-index: 500;
            pointer-events: none;
            animation: cornerPulse 1.5s infinite;
            box-shadow: 0 0 20px #00ff00;
        }
        
        .corner-point.confirmed {
            border-color: #ff0080;
            background: rgba(255, 0, 128, 0.3);
            box-shadow: 0 0 20px #ff0080;
            animation: confirmedPulse 1s infinite;
        }
        
        @keyframes cornerPulse {
            0%, 100% { 
                transform: scale(1); 
                opacity: 0.8; 
            }
            50% { 
                transform: scale(1.2); 
                opacity: 1; 
            }
        }
        
        @keyframes confirmedPulse {
            0%, 100% { 
                transform: scale(1) rotate(0deg); 
                opacity: 0.9; 
            }
            50% { 
                transform: scale(1.1) rotate(180deg); 
                opacity: 1; 
            }
        }
        
        .surface-outline {
            position: absolute;
            border: 2px solid #00ffff;
            z-index: 400;
            pointer-events: none;
            background: rgba(0, 255, 255, 0.1);
            border-radius: 5px;
            animation: surfaceGlow 2s infinite;
        }
        
        @keyframes surfaceGlow {
            0%, 100% { 
                box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            }
            50% { 
                box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
            }
        }
        
        .corner-label {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: bold;
            white-space: nowrap;
        }
        
        #scan-crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border: 2px solid #fff;
            border-radius: 50%;
            z-index: 600;
            pointer-events: none;
            animation: crosshairScan 2s infinite;
        }
        
        #scan-crosshair::before,
        #scan-crosshair::after {
            content: '';
            position: absolute;
            background: #fff;
        }
        
        #scan-crosshair::before {
            top: 50%;
            left: 15%;
            width: 70%;
            height: 2px;
            transform: translateY(-50%);
        }
        
        #scan-crosshair::after {
            left: 50%;
            top: 15%;
            width: 2px;
            height: 70%;
            transform: translateX(-50%);
        }
        
        @keyframes crosshairScan {
            0%, 100% { 
                opacity: 0.6;
                transform: translate(-50%, -50%) scale(1);
            }
            50% { 
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.1);
            }
        }
        
        #controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            gap: 15px;
            pointer-events: auto;
        }
        
        .control-btn {
            background: rgba(255, 255, 255, 0.95);
            border: none;
            padding: 15px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 1);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        .control-btn.primary {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
        }
        
        .control-btn.scan {
            background: linear-gradient(45deg, #2196F3, #1976D2);
            color: white;
        }
        
        .control-btn.danger {
            background: linear-gradient(45deg, #f44336, #da190b);
            color: white;
        }
        
        #permissionDialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .dialog-content {
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
            margin: 20px;
            backdrop-filter: blur(20px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
        }
        
        .dialog-btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .dialog-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }
        
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 998;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            max-width: 350px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .scan-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 255, 0.15) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.15) 1px, transparent 1px);
            background-size: 30px 30px;
            animation: gridScan 2s infinite;
            z-index: 300;
            pointer-events: none;
        }
        
        @keyframes gridScan {
            0% { opacity: 0.2; }
            50% { opacity: 0.6; }
            100% { opacity: 0.2; }
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00ffff);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }
    </style>
</head>
<body>
    <div id="permissionDialog">
        <div class="dialog-content">
            <h2>üìê Scanner de Superficies AR</h2>
            <p>Detecta 4 puntos de esquina de superficies planas</p>
            <p>üéØ <strong>Apunta hacia una mesa o superficie</strong></p>
            <p>üìç <strong>El sistema detectar√° autom√°ticamente las 4 esquinas</strong></p>
            <p>üì¶ <strong>Coloca objetos 3D precisamente en la superficie</strong></p>
            <p>üîπ Detecci√≥n autom√°tica de esquinas</p>
            <p>üîπ Colocaci√≥n precisa de objetos</p>
            <button class="dialog-btn" onclick="requestCamera()">üöÄ Iniciar Scanner</button>
        </div>
    </div>

    <div id="container" style="display: none;">
        <video id="video" autoplay muted playsinline></video>
        <div id="threejs-container"></div>
        
        <div class="scan-grid"></div>
        <div id="scan-crosshair"></div>
        
        <div id="ui">
            <h3>üìê Scanner de Superficie</h3>
            <p><strong>Estado:</strong> <span id="status">Iniciando...</span></p>
            <p><strong>Esquinas:</strong> <span id="cornerCount">0/4</span></p>
            <p><strong>Superficie:</strong> <span id="surfaceStatus">No detectada</span></p>
            <div class="progress-bar">
                <div class="progress-fill" id="scanProgress"></div>
            </div>
            <p><small>Mueve la c√°mara lentamente sobre la superficie</small></p>
        </div>
        
        <div id="instructions">
            <h3>üéØ Escaneando Superficie</h3>
            <p>Apunta hacia una mesa o superficie plana:</p>
            <ul style="text-align: left; margin: 15px 0;">
                <li>üì± <strong>Mant√©n la c√°mara estable</strong></li>
                <li>üìê <strong>Busca superficies rectangulares</strong></li>
                <li>üéØ <strong>El sistema detectar√° las 4 esquinas</strong></li>
                <li>üì¶ <strong>Luego podr√°s colocar objetos</strong></li>
            </ul>
            <p><small>La detecci√≥n es autom√°tica - solo apunta y espera</small></p>
        </div>
        
        <div id="controls">
            <button class="control-btn scan" onclick="startManualScan()">üîç Escanear Manual</button>
            <button class="control-btn primary" onclick="placeObject()">üì¶ Colocar Objeto</button>
            <button class="control-btn danger" onclick="resetScan()">üîÑ Reiniciar</button>
        </div>
    </div>

    <script>
        // Variables globales
        let video, scene, camera, renderer;
        let detectedCorners = [];
        let surfaceOutline = null;
        let placedObjects = [];
        let isInitialized = false;
        let isScanning = false;
        let scanProgress = 0;
        let animationId;
        
        // Canvas para an√°lisis de imagen
        let analysisCanvas, analysisCtx;
        
        // Superficie detectada
        let detectedSurface = null;
        
        // Inicializar Three.js
        function initThreeJS() {
            const container = document.getElementById('threejs-container');
            
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(
                75, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                1000
            );
            camera.position.set(0, 3, 5);
            
            renderer = new THREE.WebGLRenderer({ 
                alpha: true, 
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            container.appendChild(renderer.domElement);
            
            // Luces
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            animate();
        }
        
        // Solicitar permiso de c√°mara
        async function requestCamera() {
            try {
                document.getElementById('permissionDialog').style.display = 'none';
                document.getElementById('container').style.display = 'block';
                await init();
            } catch (error) {
                console.error('Error al solicitar c√°mara:', error);
                alert('Error al acceder a la c√°mara. Por favor, recarga la p√°gina y permite el acceso.');
            }
        }
        
        // Inicializar la aplicaci√≥n
        async function init() {
            if (isInitialized) return;
            
            try {
                updateStatus('Iniciando c√°mara...');
                
                video = document.getElementById('video');
                
                // Inicializar canvas de an√°lisis
                analysisCanvas = document.createElement('canvas');
                analysisCtx = analysisCanvas.getContext('2d');
                analysisCanvas.width = 640;
                analysisCanvas.height = 480;
                
                initThreeJS();
                
                const constraints = {
                    video: { 
                        facingMode: { ideal: 'environment' },
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    },
                    audio: false
                };
                
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                
                video.onloadedmetadata = () => {
                    video.play().then(() => {
                        updateStatus('‚úÖ Scanner activo');
                        startAutoScan();
                        isInitialized = true;
                    });
                };
                
            } catch (error) {
                console.error('Error en init:', error);
                updateStatus('‚ùå Error al acceder a la c√°mara');
            }
        }
        
        // Iniciar escaneo autom√°tico
        function startAutoScan() {
            isScanning = true;
            updateStatus('üîç Buscando superficie...');
            
            setInterval(() => {
                if (video && video.readyState === video.HAVE_ENOUGH_DATA && isScanning) {
                    detectSurfaceCorners();
                }
            }, 200); // Escaneo cada 200ms
        }
        
        // Detectar esquinas de superficie
        function detectSurfaceCorners() {
            if (!video || !video.videoWidth || !video.videoHeight) return;
            
            try {
                // Capturar frame actual
                analysisCtx.drawImage(video, 0, 0, analysisCanvas.width, analysisCanvas.height);
                const imageData = analysisCtx.getImageData(0, 0, analysisCanvas.width, analysisCanvas.height);
                
                // Detectar contornos y esquinas
                const corners = findRectangularSurface(imageData);
                
                if (corners && corners.length === 4) {
                    // Convertir coordenadas del canvas a coordenadas de pantalla
                    const screenCorners = corners.map(corner => ({
                        x: (corner.x / analysisCanvas.width) * window.innerWidth,
                        y: (corner.y / analysisCanvas.height) * window.innerHeight
                    }));
                    
                    updateDetectedCorners(screenCorners);
                    
                    // Calcular progreso del escaneo
                    scanProgress = Math.min(100, scanProgress + 5);
                    updateScanProgress(scanProgress);
                    
                    if (scanProgress >= 100) {
                        confirmSurface(screenCorners);
                    }
                } else {
                    // Reducir progreso si no se detecta superficie
                    scanProgress = Math.max(0, scanProgress - 2);
                    updateScanProgress(scanProgress);
                    
                    if (scanProgress === 0) {
                        clearDetectedCorners();
                    }
                }
                
            } catch (error) {
                console.error('Error en detecci√≥n:', error);
                // Crear superficie de prueba para demostraci√≥n
                createTestSurface();
            }
        }
        
        // Encontrar superficie rectangular
        function findRectangularSurface(imageData) {
            const data = imageData.data;
            const width = analysisCanvas.width;
            const height = analysisCanvas.height;
            
            // Detectar bordes usando filtro de Sobel simplificado
            const edges = detectEdges(data, width, height);
            
            // Buscar l√≠neas rectas
            const lines = findLines(edges, width, height);
            
            // Buscar intersecciones que formen un rect√°ngulo
            const corners = findRectangleCorners(lines, width, height);
            
            return corners;
        }
        
        // Detectar bordes en la imagen
        function detectEdges(data, width, height) {
            const edges = new Array(width * height).fill(0);
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    
                    // Convertir a escala de grises
                    const gray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                    
                    // Calcular gradientes Sobel
                    const gx = getGradientX(data, x, y, width);
                    const gy = getGradientY(data, x, y, width);
                    
                    // Magnitud del gradiente
                    const magnitude = Math.sqrt(gx * gx + gy * gy);
                    
                    edges[y * width + x] = magnitude > 30 ? magnitude : 0;
                }
            }
            
            return edges;
        }
        
        // Calcular gradiente X
        function getGradientX(data, x, y, width) {
            const getGray = (px, py) => {
                const idx = (py * width + px) * 4;
                return (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
            };
            
            return (-1 * getGray(x-1, y-1) + 1 * getGray(x+1, y-1) +
                    -2 * getGray(x-1, y)   + 2 * getGray(x+1, y) +
                    -1 * getGray(x-1, y+1) + 1 * getGray(x+1, y+1));
        }
        
        // Calcular gradiente Y
        function getGradientY(data, x, y, width) {
            const getGray = (px, py) => {
                const idx = (py * width + px) * 4;
                return (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
            };
            
            return (-1 * getGray(x-1, y-1) - 2 * getGray(x, y-1) - 1 * getGray(x+1, y-1) +
                     1 * getGray(x-1, y+1) + 2 * getGray(x, y+1) + 1 * getGray(x+1, y+1));
        }
        
        // Encontrar l√≠neas rectas usando transformada de Hough simplificada
        function findLines(edges, width, height) {
            const lines = [];
            const threshold = 50;
            
            // Buscar l√≠neas horizontales y verticales prominentes
            for (let y = 0; y < height; y += 10) {
                let horizontalStrength = 0;
                for (let x = 0; x < width; x++) {
                    horizontalStrength += edges[y * width + x];
                }
                if (horizontalStrength > threshold) {
                    lines.push({ type: 'horizontal', position: y, strength: horizontalStrength });
                }
            }
            
            for (let x = 0; x < width; x += 10) {
                let verticalStrength = 0;
                for (let y = 0; y < height; y++) {
                    verticalStrength += edges[y * width + x];
                }
                if (verticalStrength > threshold) {
                    lines.push({ type: 'vertical', position: x, strength: verticalStrength });
                }
            }
            
            // Ordenar por fuerza y tomar las mejores
            lines.sort((a, b) => b.strength - a.strength);
            
            return lines.slice(0, 8); // Tomar las 8 l√≠neas m√°s fuertes
        }
        
        // Encontrar esquinas del rect√°ngulo
        function findRectangleCorners(lines, width, height) {
            const horizontalLines = lines.filter(l => l.type === 'horizontal').slice(0, 2);
            const verticalLines = lines.filter(l => l.type === 'vertical').slice(0, 2);
            
            if (horizontalLines.length < 2 || verticalLines.length < 2) {
                return null;
            }
            
            // Calcular intersecciones
            const corners = [];
            
            for (let h of horizontalLines) {
                for (let v of verticalLines) {
                    corners.push({
                        x: v.position,
                        y: h.position
                    });
                }
            }
            
            // Ordenar esquinas para formar un rect√°ngulo
            if (corners.length === 4) {
                corners.sort((a, b) => {
                    if (Math.abs(a.y - b.y) < 10) {
                        return a.x - b.x;
                    }
                    return a.y - b.y;
                });
                
                // Verificar que forme un rect√°ngulo v√°lido
                const minArea = (width * height) * 0.05; // Al menos 5% del √°rea
                const area = Math.abs((corners[2].x - corners[0].x) * (corners[2].y - corners[0].y));
                
                if (area > minArea) {
                    return corners;
                }
            }
            
            return null;
        }
        
        // Crear superficie de prueba
        function createTestSurface() {
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const size = 200;
            
            const testCorners = [
                { x: centerX - size, y: centerY - size/2 },
                { x: centerX + size, y: centerY - size/2 },
                { x: centerX + size, y: centerY + size/2 },
                { x: centerX - size, y: centerY + size/2 }
            ];
            
            scanProgress += 10;
            updateScanProgress(scanProgress);
            
            if (scanProgress >= 100) {
                updateDetectedCorners(testCorners);
                confirmSurface(testCorners);
            }
        }
        
        // Actualizar esquinas detectadas
        function updateDetectedCorners(corners) {
            clearDetectedCorners();
            detectedCorners = corners;
            
            corners.forEach((corner, index) => {
                showCornerPoint(corner, index);
            });
            
            updateCornerCount(corners.length);
            
            if (corners.length === 4) {
                showSurfaceOutline(corners);
            }
        }
        
        // Mostrar punto de esquina
        function showCornerPoint(corner, index) {
            const point = document.createElement('div');
            point.className = 'corner-point';
            point.style.left = (corner.x - 10) + 'px';
            point.style.top = (corner.y - 10) + 'px';
            
            const label = document.createElement('div');
            label.className = 'corner-label';
            label.textContent = `P${index + 1}`;
            point.appendChild(label);
            
            document.body.appendChild(point);
        }
        
        // Mostrar contorno de superficie
        function showSurfaceOutline(corners) {
            if (surfaceOutline && surfaceOutline.parentNode) {
                surfaceOutline.parentNode.removeChild(surfaceOutline);
            }
            
            // Calcular bounding box
            const minX = Math.min(...corners.map(c => c.x));
            const maxX = Math.max(...corners.map(c => c.x));
            const minY = Math.min(...corners.map(c => c.y));
            const maxY = Math.max(...corners.map(c => c.y));
            
            surfaceOutline = document.createElement('div');
            surfaceOutline.className = 'surface-outline';
            surfaceOutline.style.left = minX + 'px';
            surfaceOutline.style.top = minY + 'px';
            surfaceOutline.style.width = (maxX - minX) + 'px';
            surfaceOutline.style.height = (maxY - minY) + 'px';
            
            document.body.appendChild(surfaceOutline);
        }
        
        // Confirmar superficie detectada
        function confirmSurface(corners) {
            detectedSurface = {
                corners: corners,
                center: {
                    x: corners.reduce((sum, c) => sum + c.x, 0) / 4,
                    y: corners.reduce((sum, c) => sum + c.y, 0) / 4
                },
                confirmed: true
            };
            
            // Marcar esquinas como confirmadas
            const cornerPoints = document.querySelectorAll('.corner-point');
            cornerPoints.forEach(point => {
                point.classList.add('confirmed');
            });
            
            updateStatus('‚úÖ Superficie detectada!');
            updateSurfaceStatus('üìê Mesa/Superficie confirmada');
            
            // Ocultar instrucciones
            document.getElementById('instructions').style.display = 'none';
            
            isScanning = false;
        }
        
        // Limpiar esquinas detectadas
        function clearDetectedCorners() {
            const cornerPoints = document.querySelectorAll('.corner-point');
            cornerPoints.forEach(point => {
                if (point.parentNode) {
                    point.parentNode.removeChild(point);
                }
            });
            
            if (surfaceOutline && surfaceOutline.parentNode) {
                surfaceOutline.parentNode.removeChild(surfaceOutline);
            }
            
            detectedCorners = [];
        }
        
        // Colocar objeto en la superficie
        function placeObject() {
            if (!detectedSurface || !detectedSurface.confirmed) {
                alert('‚ö†Ô∏è Primero debes escanear una superficie. Apunta hacia una mesa o superficie plana.');
                return;
            }
            
            // Crear objeto 3D
            const object = createRealisticObject();
            
            // Calcular posici√≥n 3D basada en la superficie detectada
            const worldPos = screenToWorld(detectedSurface.center);
            object.position.set(worldPos.x, worldPos.y + 0.5, worldPos.z);
            
            scene.add(object);
            placedObjects.push(object);
            
            // Animaci√≥n de aparici√≥n
            object.scale.set(0, 0, 0);
            animateObjectAppearance(object);
            
            updateStatus(`üì¶ Objeto colocado! Total: ${placedObjects.length}`);
        }
        
        // Crear objeto 3D realista
        function createRealisticObject() {
            const group = new THREE.Group();
            
            // Tipos de objetos aleatorios
            const objectTypes = ['cube', 'sphere', 'pyramid', 'torus'];
            const type = objectTypes[Math.floor(Math.random() * objectTypes.length)];
            
            let geometry, material, mesh;
            
            switch(type) {
                case 'cube':
                    geometry = new THREE.BoxGeometry(1, 1, 1);
                    material = new THREE.MeshLambertMaterial({ 
                        color: getRandomColor(),
                        transparent: true,
                        opacity: 0.8
                    });
                    break;
                    
                case 'sphere':
                    geometry = new THREE.SphereGeometry(0.5, 16, 16);
                    material = new THREE.MeshPhongMaterial({ 
                        color: getRandomColor(),
                        shininess: 100,
                        transparent: true,
                        opacity: 0.9
                    });
                    break;
                    
                case 'pyramid':
                    geometry = new THREE.ConeGeometry(0.6, 1.2, 4);
                    material = new THREE.MeshLambertMaterial({ 
                        color: getRandomColor(),
                        transparent: true,
                        opacity: 0.8
                    });
                    break;
                    
                case 'torus':
                    geometry = new THREE.TorusGeometry(0.4, 0.2, 8, 16);
                    material = new THREE.MeshPhongMaterial({ 
                        color: getRandomColor(),
                        shininess: 80,
                        transparent: true,
                        opacity: 0.8
                    });
                    break;
            }
            
            mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // Rotaci√≥n aleatoria
            mesh.rotation.x = Math.random() * Math.PI * 2;
            mesh.rotation.y = Math.random() * Math.PI * 2;
            mesh.rotation.z = Math.random() * Math.PI * 2;
            
            group.add(mesh);
            
            // A√±adir brillo/outline
            const outlineGeometry = geometry.clone();
            const outlineMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                side: THREE.BackSide,
                transparent: true,
                opacity: 0.3
            });
            const outline = new THREE.Mesh(outlineGeometry, outlineMaterial);
            outline.scale.multiplyScalar(1.05);
            group.add(outline);
            
            return group;
        }
        
        // Obtener color aleatorio
        function getRandomColor() {
            const colors = [
                0xff6b6b, 0x4ecdc4, 0x45b7d1, 0xf9ca24, 
                0xf0932b, 0xeb4d4b, 0x6c5ce7, 0xa29bfe,
                0xfd79a8, 0xe84393, 0x00b894, 0x00cec9
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        }
        
        // Convertir coordenadas de pantalla a mundo 3D
        function screenToWorld(screenPos) {
            const x = (screenPos.x / window.innerWidth) * 2 - 1;
            const y = -(screenPos.y / window.innerHeight) * 2 + 1;
            
            // Proyectar al plano de la superficie (Y = 0)
            const vector = new THREE.Vector3(x, y, 0.5);
            vector.unproject(camera);
            
            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.y / dir.y;
            const pos = camera.position.clone().add(dir.multiplyScalar(distance));
            
            return pos;
        }
        
        // Animar aparici√≥n del objeto
        function animateObjectAppearance(object) {
            const startTime = Date.now();
            const duration = 800;
            
            function animateFrame() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Escala con efecto bounce
                const scale = easeOutBounce(progress);
                object.scale.set(scale, scale, scale);
                
                // Rotaci√≥n
                object.rotation.y = progress * Math.PI * 2;
                
                if (progress < 1) {
                    requestAnimationFrame(animateFrame);
                }
            }
            
            animateFrame();
        }
        
        // Funci√≥n de easing bounce
        function easeOutBounce(t) {
            if (t < 1 / 2.75) {
                return 7.5625 * t * t;
            } else if (t < 2 / 2.75) {
                return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
            } else if (t < 2.5 / 2.75) {
                return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
            } else {
                return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
            }
        }
        
        // Escaneo manual
        function startManualScan() {
            if (isScanning) {
                alert('üîç El escaneo ya est√° en progreso. Apunta hacia una superficie plana.');
                return;
            }
            
            resetScan();
            updateStatus('üîç Escaneo manual iniciado');
            document.getElementById('instructions').style.display = 'block';
            startAutoScan();
        }
        
        // Reiniciar escaneo
        function resetScan() {
            isScanning = false;
            scanProgress = 0;
            detectedSurface = null;
            
            clearDetectedCorners();
            updateScanProgress(0);
            updateStatus('üîÑ Scanner reiniciado');
            updateSurfaceStatus('No detectada');
            updateCornerCount(0);
            
            // Limpiar objetos colocados
            placedObjects.forEach(obj => {
                scene.remove(obj);
            });
            placedObjects = [];
            
            // Mostrar instrucciones nuevamente
            document.getElementById('instructions').style.display = 'block';
        }
        
        // Funciones de actualizaci√≥n de UI
        function updateStatus(status) {
            document.getElementById('status').textContent = status;
        }
        
        function updateSurfaceStatus(status) {
            document.getElementById('surfaceStatus').textContent = status;
        }
        
        function updateCornerCount(count) {
            document.getElementById('cornerCount').textContent = `${count}/4`;
        }
        
        function updateScanProgress(progress) {
            document.getElementById('scanProgress').style.width = progress + '%';
        }
        
        // Loop de animaci√≥n
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            // Rotar objetos colocados
            placedObjects.forEach((obj, index) => {
                obj.rotation.y += 0.01 + (index * 0.002);
                obj.position.y = 0.5 + Math.sin(Date.now() * 0.001 + index) * 0.1;
            });
            
            // Mover c√°mara sutilmente para simular tracking
            if (detectedSurface && detectedSurface.confirmed) {
                camera.position.x += (Math.sin(Date.now() * 0.0005) * 0.02);
                camera.position.z += (Math.cos(Date.now() * 0.0003) * 0.02);
                camera.lookAt(0, 0, 0);
            }
            
            renderer.render(scene, camera);
        }
        
        // Manejar redimensionamiento
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Prevenir scroll en m√≥viles
        document.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });
        
        // Limpiar al cerrar
        window.addEventListener('beforeunload', () => {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            if (video && video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
            }
        });
        
        // Debug: Mostrar informaci√≥n de la superficie
        function debugSurface() {
            if (detectedSurface) {
                console.log('Superficie detectada:', detectedSurface);
                console.log('Esquinas:', detectedSurface.corners);
                console.log('Centro:', detectedSurface.center);
            } else {
                console.log('No hay superficie detectada');
            }
        }
        
        // A√±adir funci√≥n debug al objeto window para testing
        window.debugSurface = debugSurface;
        window.createTestSurface = createTestSurface;
        
        // Inicializar cuando se cargue la p√°gina
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üöÄ AR Surface Scanner cargado');
            console.log('üì± Haz clic en "Iniciar Scanner" para comenzar');
        });
    </script>
</body>
</html>
