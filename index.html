<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR sin Marcadores - Detecci√≥n de Superficies</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: #000;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 15px;
            font-size: 14px;
            max-width: 280px;
            backdrop-filter: blur(10px);
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            width: 40px;
            height: 40px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
        }
        
        #crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
        }
        
        #controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .control-btn {
            background: rgba(255, 255, 255, 0.9);
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            font-size: 12px;
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 1);
            transform: scale(1.05);
        }
        
        .control-btn.active {
            background: #4CAF50;
            color: white;
        }
        
        #placeBtn {
            background: #FF6B6B;
            color: white;
            font-size: 16px;
            padding: 15px 30px;
            margin: 10px;
        }
        
        #placeBtn:hover {
            background: #FF5252;
        }
        
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 998;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
        
        .surface-indicator {
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(76, 175, 80, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 500;
            animation: surfacePulse 1.5s infinite;
        }
        
        @keyframes surfacePulse {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.5); opacity: 0.4; }
            100% { transform: scale(1); opacity: 0.8; }
        }

        #permissionDialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .dialog-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 400px;
            margin: 20px;
        }

        .dialog-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px;
        }
    </style>
</head>
<body>
    <div id="permissionDialog">
        <div class="dialog-content">
            <h2>üì∑ Acceso a la C√°mara</h2>
            <p>Esta aplicaci√≥n necesita acceso a tu c√°mara para funcionar.</p>
            <p>Haz clic en "Permitir" cuando tu navegador lo solicite.</p>
            <button class="dialog-btn" onclick="requestCamera()">üöÄ Iniciar AR</button>
        </div>
    </div>

    <div id="container" style="display: none;">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="canvas"></canvas>
        
        <div id="ui">
            <h3>üéØ AR sin Marcadores</h3>
            <p><strong>Instrucciones:</strong></p>
            <ul>
                <li>Mueve la c√°mara lentamente</li>
                <li>Busca superficies planas</li>
                <li>Toca "Colocar" cuando veas el punto verde</li>
                <li>¬°El objeto aparecer√° en la superficie!</li>
            </ul>
            <p><small>Estado: <span id="status">Iniciando...</span></small></p>
        </div>
        
        <div id="crosshair"></div>
        
        <div id="instructions">
            <h3>üì± Mueve tu dispositivo</h3>
            <p>Apunta la c√°mara hacia superficies planas como:</p>
            <ul style="text-align: left;">
                <li>Mesa o escritorio</li>
                <li>Suelo</li>
                <li>Libros o revistas</li>
                <li>Cualquier superficie plana</li>
            </ul>
            <p><small>Los puntos verdes indican superficies detectadas</small></p>
        </div>
        
        <div id="controls">
            <button class="control-btn active" onclick="changeModel('cube')">üé≤ Cubo</button>
            <button class="control-btn" onclick="changeModel('sphere')">‚öΩ Esfera</button>
            <button class="control-btn" onclick="changeModel('pyramid')">üî∫ Pir√°mide</button>
            <button class="control-btn" onclick="changeModel('pokemon')">‚ö° Pok√©mon</button>
            <button id="placeBtn" class="control-btn" onclick="placeObject()">üìç Colocar Objeto</button>
            <button class="control-btn" onclick="clearObjects()">üóëÔ∏è Limpiar</button>
        </div>
    </div>

    <script>
        // Variables globales
        let scene, camera, renderer, video, canvas, ctx;
        let objects = [];
        let currentModel = 'cube';
        let surfacePoints = [];
        let isTracking = false;
        let placedObjects = [];
        let isInitialized = false;
        
        // Solicitar permiso de c√°mara
        async function requestCamera() {
            try {
                document.getElementById('permissionDialog').style.display = 'none';
                document.getElementById('container').style.display = 'block';
                await init();
            } catch (error) {
                console.error('Error al solicitar c√°mara:', error);
                alert('Error al acceder a la c√°mara. Por favor, recarga la p√°gina y permite el acceso.');
            }
        }

        // Inicializar la aplicaci√≥n
        async function init() {
            if (isInitialized) return;
            
            try {
                updateStatus('Iniciando c√°mara...');
                
                // Configurar elementos
                video = document.getElementById('video');
                canvas = document.getElementById('canvas');
                ctx = canvas.getContext('2d');
                
                // Configurar Three.js
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas, 
                    alpha: true,
                    antialias: true 
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x000000, 0);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Configurar luces
                setupLights();
                
                // Solicitar acceso a la c√°mara
                const constraints = {
                    video: { 
                        facingMode: { ideal: 'environment' },
                        width: { ideal: 1280, max: 1920 },
                        height: { ideal: 720, max: 1080 }
                    },
                    audio: false
                };
                
                updateStatus('Solicitando acceso a c√°mara...');
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                
                video.srcObject = stream;
                
                // Esperar a que el video est√© listo
                video.onloadedmetadata = () => {
                    video.play().then(() => {
                        updateStatus('‚úÖ C√°mara iniciada - Busca superficies');
                        document.getElementById('instructions').style.display = 'block';
                        
                        // Ajustar canvas al tama√±o del video
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        
                        // Iniciar detecci√≥n de superficies
                        startSurfaceDetection();
                        
                        // Iniciar renderizado
                        animate();
                        
                        isInitialized = true;
                    }).catch(error => {
                        console.error('Error al reproducir video:', error);
                        updateStatus('‚ùå Error al iniciar video');
                    });
                };
                
            } catch (error) {
                console.error('Error en init:', error);
                updateStatus('‚ùå Error al acceder a la c√°mara');
                
                // Mostrar mensaje de error m√°s detallado
                if (error.name === 'NotAllowedError') {
                    alert('Acceso a la c√°mara denegado. Por favor, permite el acceso y recarga la p√°gina.');
                } else if (error.name === 'NotFoundError') {
                    alert('No se encontr√≥ ninguna c√°mara. Aseg√∫rate de que tu dispositivo tenga una c√°mara.');
                } else {
                    alert('Error al acceder a la c√°mara: ' + error.message);
                }
            }
        }
        
        // Simulaci√≥n mejorada de detecci√≥n de superficies
        function startSurfaceDetection() {
            setInterval(() => {
                if (video && video.readyState === video.HAVE_ENOUGH_DATA) {
                    detectSurfaces();
                }
            }, 300);
        }
        
        // Detectar superficies usando an√°lisis de imagen b√°sico
        function detectSurfaces() {
            if (!video || !video.videoWidth || !video.videoHeight) return;
            
            // Limpiar puntos anteriores
            clearSurfaceIndicators();
            surfacePoints = [];
            
            try {
                // Crear canvas temporal para an√°lisis
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = Math.min(video.videoWidth, 320);
                tempCanvas.height = Math.min(video.videoHeight, 240);
                
                // Dibujar video en canvas temporal
                tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);
                
                // Obtener datos de imagen
                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const data = imageData.data;
                
                // An√°lisis simple de superficies basado en variaci√≥n de color
                const gridSize = 20;
                const threshold = 30;
                
                for (let y = gridSize; y < tempCanvas.height - gridSize; y += gridSize) {
                    for (let x = gridSize; x < tempCanvas.width - gridSize; x += gridSize) {
                        // Calcular varianza en una regi√≥n peque√±a
                        let variance = calculateVariance(data, x, y, gridSize, tempCanvas.width);
                        
                        // Si la varianza es baja, podr√≠a ser una superficie plana
                        if (variance < threshold && Math.random() > 0.6) {
                            // Convertir coordenadas de canvas a pantalla
                            const screenX = (x / tempCanvas.width) * window.innerWidth;
                            const screenY = (y / tempCanvas.height) * window.innerHeight;
                            
                            surfacePoints.push({ x: screenX, y: screenY, confidence: 1 - (variance / threshold) });
                            showSurfaceIndicator(screenX, screenY);
                        }
                    }
                }
                
                // A√±adir algunos puntos simulados para asegurar detecci√≥n
                if (surfacePoints.length < 3) {
                    for (let i = 0; i < 3; i++) {
                        const x = Math.random() * window.innerWidth;
                        const y = window.innerHeight * 0.3 + Math.random() * window.innerHeight * 0.4;
                        
                        surfacePoints.push({ x, y, confidence: 0.7 });
                        showSurfaceIndicator(x, y);
                    }
                }
                
                if (surfacePoints.length > 0) {
                    updateStatus(`üü¢ ${surfacePoints.length} superficie(s) detectada(s)`);
                    document.getElementById('instructions').style.display = 'none';
                    isTracking = true;
                } else {
                    updateStatus('üîç Buscando superficies...');
                    if (placedObjects.length === 0) {
                        document.getElementById('instructions').style.display = 'block';
                    }
                    isTracking = false;
                }
                
            } catch (error) {
                console.error('Error en detecci√≥n de superficies:', error);
                // Continuar con detecci√≥n simulada
                simulateSurfaceDetection();
            }
        }
        
        // Calcular varianza de color en una regi√≥n
        function calculateVariance(data, centerX, centerY, size, width) {
            let values = [];
            const halfSize = Math.floor(size / 2);
            
            for (let dy = -halfSize; dy < halfSize; dy++) {
                for (let dx = -halfSize; dx < halfSize; dx++) {
                    const x = centerX + dx;
                    const y = centerY + dy;
                    const index = (y * width + x) * 4;
                    
                    if (index >= 0 && index < data.length - 3) {
                        // Convertir a escala de grises
                        const gray = data[index] * 0.299 + data[index + 1] * 0.587 + data[index + 2] * 0.114;
                        values.push(gray);
                    }
                }
            }
            
            if (values.length === 0) return 100;
            
            const mean = values.reduce((a, b) => a + b, 0) / values.length;
            const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
            
            return variance;
        }
        
        // Detecci√≥n simulada como respaldo
        function simulateSurfaceDetection() {
            for (let i = 0; i < 3; i++) {
                if (Math.random() > 0.5) {
                    const x = Math.random() * window.innerWidth;
                    const y = window.innerHeight * 0.3 + Math.random() * window.innerHeight * 0.4;
                    
                    surfacePoints.push({ x, y, confidence: 0.8 });
                    showSurfaceIndicator(x, y);
                }
            }
        }
        
        // Mostrar indicador de superficie
        function showSurfaceIndicator(x, y) {
            const indicator = document.createElement('div');
            indicator.className = 'surface-indicator';
            indicator.style.left = (x - 10) + 'px';
            indicator.style.top = (y - 10) + 'px';
            document.getElementById('container').appendChild(indicator);
            
            // Remover despu√©s de 2 segundos
            setTimeout(() => {
                if (indicator && indicator.parentNode) {
                    indicator.parentNode.removeChild(indicator);
                }
            }, 2000);
        }
        
        // Limpiar indicadores de superficie
        function clearSurfaceIndicators() {
            const indicators = document.querySelectorAll('.surface-indicator');
            indicators.forEach(indicator => {
                if (indicator.parentNode) {
                    indicator.parentNode.removeChild(indicator);
                }
            });
        }
        
        // Crear modelo 3D
        function createModel(type) {
            let geometry, material, mesh;
            
            switch(type) {
                case 'cube':
                    geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                    material = new THREE.MeshPhongMaterial({ 
                        color: 0x4CC3D9,
                        shininess: 100
                    });
                    break;
                    
                case 'sphere':
                    geometry = new THREE.SphereGeometry(0.3, 32, 32);
                    material = new THREE.MeshPhongMaterial({ 
                        color: 0xEF2D5E,
                        shininess: 100
                    });
                    break;
                    
                case 'pyramid':
                    geometry = new THREE.ConeGeometry(0.3, 0.6, 4);
                    material = new THREE.MeshPhongMaterial({ 
                        color: 0xFFC65D,
                        shininess: 100
                    });
                    break;
                    
                case 'pokemon':
                    // Crear un "Pok√©mon" simple con formas b√°sicas
                    const group = new THREE.Group();
                    
                    // Cuerpo
                    const bodyGeometry = new THREE.SphereGeometry(0.3, 32, 32);
                    const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0xFFD700 });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    group.add(body);
                    
                    // Orejas
                    const earGeometry = new THREE.ConeGeometry(0.1, 0.3, 8);
                    const earMaterial = new THREE.MeshPhongMaterial({ color: 0xFFD700 });
                    
                    const ear1 = new THREE.Mesh(earGeometry, earMaterial);
                    ear1.position.set(-0.2, 0.3, 0.1);
                    ear1.rotation.z = -0.3;
                    group.add(ear1);
                    
                    const ear2 = new THREE.Mesh(earGeometry, earMaterial);
                    ear2.position.set(0.2, 0.3, 0.1);
                    ear2.rotation.z = 0.3;
                    group.add(ear2);
                    
                    // Puntas negras de orejas
                    const tipGeometry = new THREE.SphereGeometry(0.05, 16, 16);
                    const tipMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
                    
                    const tip1 = new THREE.Mesh(tipGeometry, tipMaterial);
                    tip1.position.set(-0.2, 0.45, 0.1);
                    group.add(tip1);
                    
                    const tip2 = new THREE.Mesh(tipGeometry, tipMaterial);
                    tip2.position.set(0.2, 0.45, 0.1);
                    group.add(tip2);
                    
                    return group;
            }
            
            mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            return mesh;
        }
        
        // Colocar objeto en superficie
        function placeObject() {
            if (!isTracking || surfacePoints.length === 0) {
                updateStatus('‚ùå No hay superficies detectadas');
                return;
            }
            
            // Usar el punto m√°s cercano al centro o el de mayor confianza
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            
            let bestPoint = surfacePoints[0];
            let bestScore = 0;
            
            surfacePoints.forEach(point => {
                const distance = Math.sqrt(
                    Math.pow(point.x - centerX, 2) + 
                    Math.pow(point.y - centerY, 2)
                );
                const normalizedDistance = 1 - (distance / Math.sqrt(centerX * centerX + centerY * centerY));
                const score = (point.confidence || 0.5) * 0.5 + normalizedDistance * 0.5;
                
                if (score > bestScore) {
                    bestScore = score;
                    bestPoint = point;
                }
            });
            
            // Crear y colocar el objeto
            const model = createModel(currentModel);
            
            // Convertir coordenadas de pantalla a mundo 3D
            const worldX = (bestPoint.x - centerX) / 300;
            const worldZ = (bestPoint.y - centerY) / 300;
            
            model.position.set(worldX, 0, worldZ);
            
            // A√±adir animaciones
            addAnimations(model);
            
            scene.add(model);
            placedObjects.push(model);
            
            updateStatus(`‚úÖ ${getModelName(currentModel)} colocado!`);
            
            // Efecto de colocaci√≥n
            model.scale.set(0.1, 0.1, 0.1);
            animateScale(model, { x: 1, y: 1, z: 1 }, 500);
        }
        
        // A√±adir animaciones a los objetos
        function addAnimations(object) {
            object.userData.animate = true;
            object.userData.rotationSpeed = {
                x: (Math.random() - 0.5) * 0.02,
                y: (Math.random() - 0.5) * 0.02,
                z: (Math.random() - 0.5) * 0.02
            };
            
            object.userData.floatOffset = Math.random() * Math.PI * 2;
            object.userData.floatSpeed = 0.02 + Math.random() * 0.02;
        }
        
        // Animar escala
        function animateScale(object, targetScale, duration) {
            const startScale = { ...object.scale };
            const startTime = Date.now();
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                object.scale.x = startScale.x + (targetScale.x - startScale.x) * easeProgress;
                object.scale.y = startScale.y + (targetScale.y - startScale.y) * easeProgress;
                object.scale.z = startScale.z + (targetScale.z - startScale.z) * easeProgress;
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }
            
            animate();
        }
        
        // Cambiar modelo actual
        function changeModel(modelType) {
            document.querySelectorAll('.control-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            currentModel = modelType;
            updateStatus(`Modelo seleccionado: ${getModelName(modelType)}`);
        }
        
        // Limpiar todos los objetos
        function clearObjects() {
            placedObjects.forEach(obj => {
                scene.remove(obj);
            });
            placedObjects = [];
            updateStatus('üóëÔ∏è Objetos eliminados');
        }
        
        // Obtener nombre del modelo
        function getModelName(type) {
            const names = {
                'cube': 'Cubo M√°gico',
                'sphere': 'Esfera Brillante',
                'pyramid': 'Pir√°mide Dorada',
                'pokemon': 'Pikachu'
            };
            return names[type] || type;
        }
        
        // Actualizar estado
        function updateStatus(message) {
            const statusEl = document.getElementById('status');
            if (statusEl) {
                statusEl.textContent = message;
            }
        }
        
        // Configurar iluminaci√≥n
        function setupLights() {
            // Luz ambiental
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            // Luz direccional principal
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Luz puntual
            const pointLight = new THREE.PointLight(0xffffff, 0.5, 100);
            pointLight.position.set(0, 5, 0);
            scene.add(pointLight);
        }
        
        // Bucle de animaci√≥n
        function animate() {
            if (!isInitialized) return;
            
            requestAnimationFrame(animate);
            
            // Animar objetos colocados
            placedObjects.forEach(obj => {
                if (obj.userData.animate) {
                    obj.rotation.x += obj.userData.rotationSpeed.x;
                    obj.rotation.y += obj.userData.rotationSpeed.y;
                    obj.rotation.z += obj.userData.rotationSpeed.z;
                    
                    obj.userData.floatOffset += obj.userData.floatSpeed;
                    obj.position.y = Math.sin(obj.userData.floatOffset) * 0.1;
                }
            });
            
            renderer.render(scene, camera);
        }
        
        // Manejar redimensionado
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
        
        // Verificar soporte de navegador
        function checkBrowserSupport() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                alert('Tu navegador no soporta acceso a la c√°mara. Usa Chrome, Firefox o Safari m√°s reciente.');
                return false;
            }
            return true;
        }
        
        // Inicializar cuando se carga la p√°gina
        window.addEventListener('load', () => {
            if (checkBrowserSupport()) {
                // La inicializaci√≥n se maneja por el bot√≥n de permisos
            }
        });
    </script>
</body>
</html>
